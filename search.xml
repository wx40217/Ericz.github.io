<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CodeForces 1185B Email from Polycarp]]></title>
    <url>%2F2019%2F07%2F15%2FCodeForces-1185B-Email-from-Polycarp%2F</url>
    <content type="text"><![CDATA[Methodius received an email from his friend Polycarp. However, Polycarp’s keyboard is broken, so pressing a key on it once may cause the corresponding symbol to appear more than once (if you press a key on a regular keyboard, it prints exactly one symbol).For example, as a result of typing the word “hello”, the following words could be printed: “hello”, “hhhhello”, “hheeeellllooo”, but the following could not be printed: “hell”, “helo”, “hhllllooo”.Note, that when you press a key, the corresponding symbol must appear (possibly, more than once). The keyboard is broken in a random manner, it means that pressing the same key you can get the different number of letters in the result.For each word in the letter, Methodius has guessed what word Polycarp actually wanted to write, but he is not sure about it, so he asks you to help him.You are given a list of pairs of words. For each pair, determine if the second word could be printed by typing the first one on Polycarp’s keyboard.InputThe first line of the input contains one integer n (1≤n≤105) — the number of pairs to check. Further input contains n descriptions of pairs.The first line of each description contains a single non-empty word s consisting of lowercase Latin letters. The second line of the description contains a single non-empty word t consisting of lowercase Latin letters. The lengths of both strings are not greater than 106.It is guaranteed that the total length of all words s in the input is not greater than 106. Also, it is guaranteed that the total length of all words t in the input is not greater than 106.OutputOutput n lines. In the i-th line for the i-th pair of words s and t print YES if the word t could be printed by typing the word s. Otherwise, print NO.复健真快乐你键盘坏了，打字会粘连（打一个字母可能出来几个字母），给你字符串S和T，判断T是否可能是你打S打出来的。一段时间不做题水平确实有下降，这题第一反映居然是开map统计每个字母出现次数。实际我们可以发现，T可以是打S打出来只有两种情况：1、对应位置相同 2、对应位置不同但是连着的前几个字符相同且和S的对应位置相同 然后模拟就行了。要注意T前面和S相同但是比S尾部少字母的情况。AC代码：1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; string a,b; cin&gt;&gt;a&gt;&gt;b; int flag=1; int pos=0; for(int i=0;i&lt;b.size();i++) &#123; if(b[i]==a[pos]) pos++; else if (i&gt;0&amp;&amp;b[i-1]==b[i]) continue; else &#123; flag=0; break; &#125; &#125; if(pos!=a.size()) flag=0; if(flag) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>水</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南昌打铁感想]]></title>
    <url>%2F2019%2F06%2F05%2F%E5%8D%97%E6%98%8C%E6%89%93%E9%93%81%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[嘛，其实也没啥感想。只能说自己太菜了吧，就撕一道题还撕错了。cls主张要分工合作，但是现在的问题是会的东西太少，分工合作也不现实。准备了好久的各种数据结构，到最后也就碰上个字典树，AC自动机完全没题，线段树出了也不会做（苦笑）。再加上有新人进队，以后去比赛还要先打架，以我现在的实力大概是没机会出去了。仔细想想，还是刷CF吧，现在已经有点不知道该学什么了，一边做题一边找不会的点来学，可能还要机会吧。]]></content>
      <categories>
        <category>水</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 4022 Bombing]]></title>
    <url>%2F2019%2F05%2F30%2FHDU-4022-Bombing%2F</url>
    <content type="text"><![CDATA[It’s a cruel war which killed millions of people and ruined series of cities. In order to stop it, let’s bomb the opponent’s base.It seems not to be a hard work in circumstances of street battles, however, you’ll be encountered a much more difficult instance: recounting exploits of the military. In the bombing action, the commander will dispatch a group of bombers with weapons having the huge destructive power to destroy all the targets in a line. Thanks to the outstanding work of our spy, the positions of all opponents’ bases had been detected and marked on the map, consequently, the bombing plan will be sent to you.Specifically, the map is expressed as a 2D-plane with some positions of enemy’s bases marked on. The bombers are dispatched orderly and each of them will bomb a vertical or horizontal line on the map. Then your commanded wants you to report that how many bases will be destroyed by each bomber. Notice that a ruined base will not be taken into account when calculating the exploits of later bombers.InputMultiple test cases and each test cases starts with two non-negative integer N (N&lt;=100,000) and M (M&lt;=100,000) denoting the number of target bases and the number of scheduled bombers respectively. In the following N line, there is a pair of integers x and y separated by single space indicating the coordinate of position of each opponent’s base. The following M lines describe the bombers, each of them contains two integers c and d where c is 0 or 1 and d is an integer with absolute value no more than 10 9, if c = 0, then this bomber will bomb the line x = d, otherwise y = d. The input will end when N = M = 0 and the number of test cases is no more than 50.OutputFor each test case, output M lines, the ith line contains a single integer denoting the number of bases that were destroyed by the corresponding bomber in the input. Output a blank line after each test case.Sample Input3 21 21 32 30 11 30 0Sample Output21基础的离散化，实际上用map的过程就是一个离散化……然后因为有重复的点对用了multiset，大概是第一次用这个stl吧，用法和set差不多。AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int,multiset&lt;int&gt; &gt;mpx;map&lt;int,multiset&lt;int&gt; &gt;mpy;int n,m;int main()&#123; int a,c; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n&amp;&amp;m) &#123; mpx.clear(); mpy.clear(); for(int i=0;i&lt;n;i++) &#123; scanf("%d %d",&amp;a,&amp;c); mpx[a].insert(c); mpy[c].insert(a); &#125; for(int i=0;i&lt;m;i++) &#123; scanf("%d %d",&amp;a,&amp;c); if(a==0) &#123; cout&lt;&lt;mpx[c].size()&lt;&lt;endl; for(auto it=mpx[c].begin();it!=mpx[c].end();it++) &#123; int y=(*it); mpy[y].erase(mpy[y].find(c)); &#125; mpx[c].clear(); &#125; else &#123; cout&lt;&lt;mpy[c].size()&lt;&lt;endl; for(auto it=mpy[c].begin();it!=mpy[c].end();it++) &#123; int x=(*it); mpx[x].erase(mpx[x].find(c)); &#125; mpy[c].clear(); &#125; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 3756 Dome of Circus]]></title>
    <url>%2F2019%2F05%2F29%2FHDU-3756-Dome-of-Circus%2F</url>
    <content type="text"><![CDATA[A travelling circus faces a tough challenge in designing the dome for its performances. The circus has a number of shows that happen above the stage in the air under the dome. Various rigs, supports, and anchors must be installed over the stage, but under the dome. The dome itself must rise above the center of the stage and has a conical shape. The space under the dome must be air-conditioned, so the goal is to design the dome that contains minimal volume.You are given a set of n points in the space; (xi, yi, zi) for 1 ≤ i ≤ n are the coordinates of the points in the air above the stage that must be covered by the dome. The ground is denoted by the plane z = 0, with positive z coordinates going up. The center of the stage is on the ground at the point (0, 0, 0).The tip of the dome must be located at some point with coordinates (0, 0, h) with h &gt; 0. The dome must have a conical shape that touches the ground at the circle with the center in the point (0, 0, 0) and with the radius of r. The dome must contain or touch all the n given points. The dome must have the minimal volume, given the above constraints.InputThe input begins with an integer T. The next T blocks each represents a case. The first line of each case contains a single integer number n (1 ≤ n ≤ 10 000) - the number of points under the dome. The following n lines describe points with three floating point numbers xi, yi, and zi per line - the coordinates of i-th point. All coordinates do not exceed 1000 by their absolute value and have at most 2 digits after decimal point. All zi are positive. There is at least one point with non-zero xi or yi.OutputFor each case , write to the output file a single line with two floating point numbers h and r - the height and the base radius of the dome. The numbers must be precise up to 3 digits after decimal point.Sample Input311.00 0.00 1.0021.00 0.00 1.000.00 1.50 0.5031.00 0.00 1.000.00 1.50 0.50-0.50 -0.50 1.00Sample Output3.000 1.5002.000 2.0002.000 2.000这是一个很有意思的题，虽然是三维的，但是可以很容易的转化到二维去。来看X-Z这个平面，我们将所有的点进行圆周映射，然后将所有的点都投影到X-Z平面的的第一象限去，然后问题就转化成了在X-Z平面上找到一条斜率为负的直线L，L和X正方向、Z正方向围成的三角形包含所有点，如果假设L和X轴的交点为R，和Z轴焦点为H，要求piHR^2的值最小。然后我们来看看H和R之间有什么千丝万缕的关系。首先L这条线必定和某一个给定的点擦边，也就是经过那个点，我们假设它经过P(a, b)， 并且L的斜率为K(K &lt; 0)，那么L的方程就可以表示为 L: y = K (x - a) + b，则H和R就可以利用这个方程表示出来：H = -a K + b;R = -b / K + a;那么所求的圆锥的体积就是：V = piHR^2 = pi (-a K + b) (-b / K + a) ^ 2容易得到V(K)这个函数的导数：V’(K) = - pi (aK^2 + 2bK) (aK - b)^2 / K^2影响这个导数的正负性的唯一条件是 -(aK^2 + 2bK)当-2b/a &lt; K &lt; 0时V’(K)大于零，也就是V的值是随着K递增的。当K &lt; -2b/a时V’(K)小于零，也就是V的值是随着K递减的。于是可以得出一个结论，当K = -2b/a 时V取得最小值。于是我们知道了V的单峰性，然后就可以通过枚举半径R，因为R对于V具有单谷性，所以枚举R的时候可以采用三分。每次通过三分R找到最小的H，这个过程可以通过枚举每个点，找到最大的极角alpha，Rtan(alpha)就是H了。这里需要注意的就是精度问题了。这些都是我复制黏贴的……作为一个高数七十分选手，处理数学问题实在是很不得心应手（团队毒瘤型选手）。但是这道题主要是为了锻炼使用三分的能力。众所周知，二分只能处理单调区间的查找，而三分处理的是查找凸/凹函数最值的问题（如图）。（1）与二分法类似，先取整个区间的中间值mid。mid = (left + right) / 2;（2）再取右侧区间的中间值midmid，从而把区间分为三个小区间。midmid = (mid + right) / 2;（3）如果mid比midmid更靠近最值，我们就舍弃右区间，否则我们舍弃左区间。比较mid与midmid谁最靠近最值，只需要确定mid所在的函数值与midmid所在的函数值的大小。当最值为最大值时，mid与midmid中较大的那个自然更为靠近最值。最值为最小值时同理。if (cal(mid) &gt; cal(midmid))right = midmid;elseleft = mid;（4）、重复（1）（2）（3）直至找到最值。过程就是这样一个过程，由于本题是最小值，所以舍弃方向相反。AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;const double eps=1e-7;int n;struct node&#123; double x,y,z;&#125;p[maxn];double calc(double r)&#123; double h=0; for(int i=1;i&lt;=n;i++) &#123; double tmp=r*p[i].z/(r-sqrt(p[i].x*p[i].x+p[i].y*p[i].y)); h=max(tmp,h); &#125; return h*r*r;&#125;void solve()&#123; double r=1e6,l=0; while(r-l&gt;eps) &#123; double mid=(l+r)/2; double midmid=(mid+r)/2; double s1=calc(mid); double s2=calc(midmid); if(s1&lt;s2) r=midmid; else l=mid; &#125; double h=0; for(int i=1;i&lt;=n;i++) &#123; double tmp=r*p[i].z/(r-sqrt(p[i].x*p[i].x+p[i].y*p[i].y)); h=max(h,tmp); &#125; printf("%.3lf %.3lf\n",h,r);&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) scanf("%lf%lf%lf",&amp;p[i].x,&amp;p[i].y,&amp;p[i].z); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-2899 Strange fuction]]></title>
    <url>%2F2019%2F05%2F25%2FHDU-2899-Strange-fuction%2F</url>
    <content type="text"><![CDATA[Now, here is a fuction:F(x) = 6 x^7+8x^6+7x^3+5x^2-y*x (0 &lt;= x &lt;=100)Can you find the minimum value when x is between 0 and 100.InputThe first line of the input contains an integer T(1&lt;=T&lt;=100) which means the number of test cases. Then T lines follow, each line has only one real numbers Y.(0 &lt; Y &lt;1e10)OutputJust the minimum value (accurate up to 4 decimal places),when x is between 0 and 100.Sample Input2100200Sample Output-74.4291-178.8534求曲线的最小值，也就是导数的零点。因为函数给定了，可以手动求导数然后二分答案。这次皮了一下，用了牛顿迭代求零点。牛顿迭代的核心公式就是$x_{n+1}=x_n-\frac{f(x_n)}{f’(x_n)}$这个公式，不断迭代直到f(x)足够趋近0，放在这个式子里就要多添一层导数，因为是求导数的零点。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const double eps=1e-9;double y;double fdd(double t)&#123; return 252*pow(t,5)+240*pow(t,4)+42*t+10;&#125;double fd(double t)&#123; return 42*pow(t,6)+48*pow(t,5)+21*pow(t,2)+10*t-y;&#125;double f(double t)&#123; return 6*pow(t,7)+8*pow(t,6)+7*pow(t,3)+5*pow(t,2)-y*t;&#125;double Newton(double t)&#123; while(fabs(fd(t))&gt;eps) &#123; t-=fd(t)/fdd(t); //cout&lt;&lt;fabs(fd(t))&lt;&lt;endl; &#125; return t;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;y; //cout&lt;&lt;y&lt;&lt;endl; double ans=0x3f3f3f3f; for(int i=0;i&lt;=100;i++) &#123; double anspos=Newton(i); if(anspos&gt;=0&amp;&amp;anspos&lt;=100) ans=min(ans,f(anspos)); //cout&lt;&lt;ans&lt;&lt;endl; &#125; printf("%.4f\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>牛顿迭代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1969 Pie]]></title>
    <url>%2F2019%2F05%2F23%2FHDU-1969-Pie%2F</url>
    <content type="text"><![CDATA[My birthday is coming up and traditionally I’m serving pie. Not just one pie, no, I have a number N of them, of various tastes and of various sizes. F of my friends are coming to my party and each of them gets a piece of pie. This should be one piece of one pie, not several small pieces since that looks messy. This piece can be one whole pie though.My friends are very annoying and if one of them gets a bigger piece than the others, they start complaining. Therefore all of them should get equally sized (but not necessarily equally shaped) pieces, even if this leads to some pie getting spoiled (which is better than spoiling the party). Of course, I want a piece of pie for myself too, and that piece should also be of the same size.What is the largest possible piece size all of us can get? All the pies are cylindrical in shape and they all have the same height 1, but the radii of the pies can be different.InputOne line with a positive integer: the number of test cases. Then for each test case:—One line with two integers N and F with 1 &lt;= N, F &lt;= 10 000: the number of pies and the number of friends.—One line with N integers ri with 1 &lt;= ri &lt;= 10 000: the radii of the pies.OutputFor each test case, output one line with the largest possible volume V such that me and my friends can all get a pie piece of size V. The answer should be given as a floating point number with an absolute error of at most 10^(-3).Sample Input33 34 3 31 24510 51 4 2 3 4 5 6 5 4 2Sample Output25.13273.141650.2655挺简单一题……但是没想到二分还真不行。先复习一下，以前从某个地方学到了二分的使用场所：1.解的上下界明显2.解的集合离散化3.能快速判断解是偏大还是偏小那我们来看这题，解的下界是0（大家都不吃），上界是体积总和（每个派都分光）；因为限制了eps，解也是离散化的；偏大偏小只要过一遍当前体积能分出多少块，和人数比较就能得出。这么一分析，算法也就出来了。AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;const double pi=acos(-1.0);vector&lt;int&gt;a;int n,f;double handle()&#123; double maxx=0,minn=0,mid,eps=1; for(int i=0;i&lt;a.size();i++) maxx+=a[i]*a[i]*pi; maxx/=f; while(fabs(eps)&gt;0.0000001) &#123; mid=(maxx+minn)/2; int num=0; for(int i=0;i&lt;a.size();i++) num+=(int)((a[i]*a[i]*pi)/mid); if(num&lt;f) maxx=mid; else minn=mid; eps=maxx-minn; &#125; return mid;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; a.clear(); cin&gt;&gt;n&gt;&gt;f; while(n--) &#123; int t; cin&gt;&gt;t; a.push_back(t); &#125; f++; printf("%.4f\n",handle()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces - 706B Interesting drink]]></title>
    <url>%2F2019%2F05%2F11%2FCodeForces-706B-Interesting-drink%2F</url>
    <content type="text"><![CDATA[Vasiliy likes to rest after a hard work, so you may often meet him in some bar nearby. As all programmers do, he loves the famous drink “Beecola”, which can be bought in n different shops in the city. It’s known that the price of one bottle in the shop i is equal to xi coins.Vasiliy plans to buy his favorite drink for q consecutive days. He knows, that on the i-th day he will be able to spent mi coins. Now, for each of the days he want to know in how many different shops he can buy a bottle of “Beecola”.InputThe first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of shops in the city that sell Vasiliy’s favourite drink.The second line contains n integers xi (1 ≤ xi ≤ 100 000) — prices of the bottles of the drink in the i-th shop.The third line contains a single integer q (1 ≤ q ≤ 100 000) — the number of days Vasiliy plans to buy the drink.Then follow q lines each containing one integer mi (1 ≤ mi ≤ 109) — the number of coins Vasiliy can spent on the i-th day.OutputPrint q integers. The i-th of them should be equal to the number of shops where Vasiliy will be able to buy a bottle of the drink on the i-th day.ExampleInput53 10 8 6 114110311Output0415NoteOn the first day, Vasiliy won’t be able to buy a drink in any of the shops.On the second day, Vasiliy can buy a drink in the shops 1, 2, 3 and 4.On the third day, Vasiliy can buy a drink only in the shop number 1.Finally, on the last day Vasiliy can buy a drink in any shop.一上手就t了，原因是店铺数量级太大，每次都去遍历一遍时间复杂度太高。考虑到要求的是比m小的店铺数量，正好符合二分的写法，直接用二分就完事了。应该一开始就想到的……AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;int x[100010];int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) scanf("%d",&amp;x[i]); sort(x,x+n); int q; cin&gt;&gt;q; while(q--) &#123; int m; cin&gt;&gt;m; if(m&lt;x[0]) cout&lt;&lt;0&lt;&lt;endl; else if(m&gt;=x[n-1]) cout&lt;&lt;n&lt;&lt;endl; else &#123; int l=0; int r=n-1; int mid; int ans; while(l&lt;=r) &#123; mid=(l+r)/2; if(x[mid]&lt;=m) &#123; ans=mid; l=mid+1; &#125; else r=mid-1; &#125; cout&lt;&lt;ans+1&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>水</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于codeforces比赛规则介绍（转载）]]></title>
    <url>%2F2019%2F05%2F11%2F%E5%85%B3%E4%BA%8Ecodeforces%E6%AF%94%E8%B5%9B%E8%A7%84%E5%88%99%E4%BB%8B%E7%BB%8D%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Codeforces简称: cf(所以谈论cf的时候经常被误会成TX的那款游戏).网址: codeforces.com 这是一个俄国的算法竞赛网站,由来自萨拉托夫州立大学、由Mike Mirzayanov领导的一个团队创立和维护,是一个举办比赛、做题和交流的平台.举办比赛和做题就不说了,“交流”指的是自带blog功能,可以求助/发布题解之类.官方语言是俄语和英语,因此可能有些偏僻的题目的题解是用俄语写的,别慌,扔给Google Translate翻成英文,可读性还是很不错的.至于英语,cf上Russian English确实有,但并不严重,题目里偶尔会出现很奇怪的表达方式或者不常用的词汇,这时候就借助样例吧,找个人问问也是可以的.cf最大的特点是比赛,所以接下来主要的篇幅用于介绍cf传统比赛的规则.在cf,所有的用户根据在以往比赛中的表现被赋予一个Rating并冠以不同的头衔,名字也会以不同的颜色显示,比如Expert是蓝色,Master是黄色,因此我们通常以颜色代指头衔.选手们按Rating以1700为界划分为Div.1和Div.2两类,相应地,cf上的比赛也会指明是Div.1还是Div.2,抑或同时进行.Div.1的比赛较难;如果同时进行,Div.1的ABC三题会和Div.2的CDE三题相同.每次比赛结束后Rating都会依据此前各个选手的Rating和公式重新计算.对于没有参加过比赛的新用户,在比赛后重新计算Rating的时候,他此前的Rating会被视为1500. 在比赛中,选手有2个小时的时间去解决5道题,而解决某题得到的分数由该题当前的分数减去(不成功的提交次数)*50,这里,某道题的分数是由比赛开始时的分数随时间线性减少得到的.同时,这里的“解决某道题”是指Pretest Passed,即,通过了一次仅含部分测试点的测评,而最终决定是否得到这道题的分数,要看比赛结束后的统一测评(System Test),如果在这时没有通过,就称FST(Failed System Test).在比赛中的提交可以看到在哪个测试点出了什么问题(例如,仅一行WA on pretest 3). 同一个Div的选手将被划分到若干个Room里,每个Room大概30位选手;当某道题Pretest Passed之后,可以选择锁定(Lock)该题代码,之后就可以查看同一个Room内其他选手该题的代码(当然了,这也是已经通过pretest的),并试图找出其中的漏洞,自己出一个数据(可以手打,也可以提交数据生成器)让这个代码不能通过,这就是Hack,有时也称Challenge.一次成功的Hack可以得到100分,而如果没有成功,将会被扣50分,分别被称为(un)successful hacking attempt. 在比赛中,选手可以看到实时的排名(Standing),也可以选择只看加了好友的选手的排名.此外,还可以看到某题有多少人通过的信息,这在某些情况下很有用.关于比赛的事情大概就是这么多.cf题库的所有题目都是在该平台上举办过的比赛的赛题,尽管WJMZBMR曾经表示由于出题人很杂cf的题目质量参差不齐,但我个人认为还是够可以的,两个小时五道题也确实很能让人得到锻炼.和Spoj形成鲜明对比的,cf的机子效率很不错,所以很容易培养出STL依赖症等等不良代码习惯,应当引起足够的注意. 在cf上做题的过程当中如果遇到困难,首先可以看数据.数据从某种程度上来说是公开的,在提交记录页面可以看到所有你的程序运行过的数据,但是太大的数据也只会显示前几行,因此也不算完全公开.cf的测试数据笔数通常会让习惯了10个点的人大吃一惊,一道题动辄几十个测试点,甚至有的有200多笔.通常来说,前面大概5组是比赛时的Pretest,一般会尽可能的涵盖各种情况,也有放个大数据卡TLE的;其后的数据规模递增,但是最后几组又不见得是极限数据——这是比赛时Hack的成果.Hack成功的数据会被追加到该题的测试数据当中. 如果数据不能解决问题,可以试图去找题解.题目页面的右下角会标出它所属的比赛的相关文档,通常会有Announcement(赛前和赛中的公告,其中赛中的公告通常是明确题意之类),有些则会有Tutorial,这就是题解,顺带一提cf上另外一个表示题解的词是Editorial.一次比赛的题解可能不是官方的,也可能不包含该次比赛全部的题目的,也有可能是用俄语写的(前面提到过了,翻译成英语就好),也有可能有好几篇(这会以Tutorial #1,#2的形式标识). 近期的比赛多半都有官方题解,以前的就不好说了.这时候需要借助另外一个神器:神犇们的代码.cf上普通题库的所有的代码都是公开的,并且支持按照提交先后(Judging Time),运行时间(Execution Time)和代码长度(Solution Size)进行排序.不仅仅是帮助做题,这个功能对于了解一道题的各种做法也是有好处的.主要的东西就介绍完了.这里再补充一点一些零散的东西. 关于Rating的计算 : 这是一种类似Elo Rating的系统,可以在cf的FAQ或Wiki百科找到更详细的信息. 关于Contribution : 在用户信息页面会见到这个东西,它用来衡量一个用户对cf的贡献程度.这个数值取决于该用户所写的blog和他对其他的blog所作出的评论的“反响”.每个blog的下方和评论的旁边都会有一个往上和往下的箭头以及一个数字,表示你可以对他进行好或者不好的评价,而数字则显示当前已有的评价,而这就是前面说到的“反响”.点击了往下的箭头会让这个数值-1,点击了往上的箭头则会+1或+2,这里+2的条件是你本身的contribution不低于+25.如果你打算做评论,请谨慎,因为在贴吧里很正常的回复可能会被认为“没意义”或者别的原因而反响很差(比如在比赛预告帖回复Good luck everyone之类的可以被-12),随而contribution也会很难看.由于这样的原因,你可以选择完全可以无视这个数值. 关于GYM : 在gym里举办的比赛基本上是ACM/ICPC规则的,可以单干,也可以组队(人数似乎没有限制).gym的题目并不会在Problemset里显示,提交之后也不能看到数据(和常规比赛时一样,仅能看到一行TLE on test 137之类),不过在名字变红[即(International) Grandmaster]之后选上Coach mode就可以看到数据.gym里别人的代码的公开性也服从前述规则.关于Virtual Participant : 有时我们会在某条提交记录的ID右上方看到一个小小的#号或者显示一个时间,鼠标移上去会出现Virtual Participant的字样.正如其字面意思,这意味着这个用户正在“虚拟”参加一场比赛.如果你虚拟地参加一场比赛,系统会在接下来的2小时内(如果gym的话另当别论)为你完全地模拟当时的情境供你练习——包括Standing等等. 关于奇葩的测评结果 : 这包括Compilation failed,Denial of Judgement和Judgement Failed.在你确认你的程序没什么重大问题之后,基本可以认定这不是你的问题而是系统出了点差错.Judgement Failed通常会呈现爆发的样子,一段时间内几页都是,当这种情况结束的时候就正常了;而Denial of Judgement仅会在某段时间内在特定的题目发生,原因可能是数据损坏之类的,可能要等上个一两天才能得到解决(也有可能在问题解决后被自动重新测评);Compilation failed我还没有见过…字面意思是编译器不干活?附 各个头衔的Rating范围和名字颜色:[2600, inf) International Grandmaster 红[2200,2600) Grandmaster 红[2050,2200) International Master 黄[1900,2050) Master 黄[1700,1900) Candidate Master 紫[1500,1700) Expert 蓝[1350,1500) Specialist 绿[1200,1350) Pupil 绿(-inf,1200) Newbie 灰附 “ALL” CodeForces Rounds Tutorial By iman_MCcodeforces.com/blog/entry/1492有些Codeforces上有人发过的题解并没有被链接到对应的题目上(即,存在题解,但是题目页面右下方并没有Tutorial链接),有可能可以在这里找到.当然这也并不是完全的,而且时不时会更新.具体里面有哪些我就不废话了,各位自己去看看吧.]]></content>
      <categories>
        <category>水</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moss代码查重系统的使用及注意点]]></title>
    <url>%2F2019%2F05%2F10%2Fmoss%E4%BB%A3%E7%A0%81%E6%9F%A5%E9%87%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[这两天校赛搬砖，一个很重要的砖就是对代码进行查重。请教了学长以后，基本掌握了使用moss进行查重的方法。moss是斯坦福大学开发的一套查重系统（官网链接），它支持多种语言的查重，对付常用的反查重套路也有自己的手段。安装与使用标准的moss使用方式需要使用邮箱申请ID，但是邮件一写进去就石沉大海。这里我们使用一个GUI的客户端mistletoe,这也是moss官网推荐的方法之一，下载安装即可。安装后的界面如图选择代码文件夹就行，因为是对AC代码查重，也不需要加入BASE FILE（如果喜欢的话可以把标程加上），注意如果代码是txt格式的话要再后缀里自己加上*.txt。然后选择对应的语言（cc就是c++），点击RUN QUERY，如果没有出现问题就会打开一个网页显示查重的结果。注意moss的代码文件编码必须是ANSI（中文即GBK），如果代码含有中文就会采用UTF8格式，建议查重前先进行统一的代码编码转换。]]></content>
      <categories>
        <category>水</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>搬砖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces - 313B Ilya and Queries]]></title>
    <url>%2F2019%2F05%2F10%2FCodeForces-313B-Ilya-and-Queries%2F</url>
    <content type="text"><![CDATA[Ilya the Lion wants to help all his friends with passing exams. They need to solve the following problem to pass the IT exam.You’ve got string s = s1s2… sn (n is the length of the string), consisting only of characters “.” and “#” and m queries. Each query is described by a pair of integers li, ri (1 ≤ li &lt; ri ≤ n). The answer to the query li, ri is the number of such integers i (li ≤ i &lt; ri), that si = si + 1.Ilya the Lion wants to help his friends but is there anyone to help him? Help Ilya, solve the problem.InputThe first line contains string s of length n (2 ≤ n ≤ 105). It is guaranteed that the given string only consists of characters “.” and “#”.The next line contains integer m (1 ≤ m ≤ 105) — the number of queries. Each of the next m lines contains the description of the corresponding query. The i-th line contains integers li, ri (1 ≤ li &lt; ri ≤ n).OutputPrint m integers — the answers to the queries in the order in which they are given in the input.Examples1234567891011121314151617181920212223242526Input......43 42 31 62 6Output1154Input#..###51 35 61 53 63 4Output11220这题本身是很水的题，但是扫描的思想很有趣，直接用数组记录到i位置前面有多少组重复的，到时候减一下就完事，很类似于前缀和。AC代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int a[maxn];int main()&#123; string s; memset(a,0,sizeof(a)); cin&gt;&gt;s; for(int i=1;i&lt;s.size();i++) if(s[i]==s[i-1]) a[i]=a[i-1]+1; else a[i]=a[i-1]; int t; cin&gt;&gt;t; while(t--) &#123; int l,r; scanf("%d%d",&amp;l,&amp;r); cout&lt;&lt;a[r-1]-a[l-1]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>水</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces - 520B Two Buttons]]></title>
    <url>%2F2019%2F05%2F10%2FCodeForces-520B-Two-Buttons%2F</url>
    <content type="text"><![CDATA[Vasya has found a strange device. On the front panel of a device there are: a red button, a blue button and a display showing some positive integer. After clicking the red button, device multiplies the displayed number by two. After clicking the blue button, device subtracts one from the number on the display. If at some point the number stops being positive, the device breaks down. The display can show arbitrarily large numbers. Initially, the display shows number n.Bob wants to get number m on the display. What minimum number of clicks he has to make in order to achieve this result?InputThe first and the only line of the input contains two distinct integers n and m (1 ≤ n, m ≤ 104), separated by a space .OutputPrint a single number — the minimum number of times one needs to push the button required to get the number m out of number n.ExamplesInput4 6Output2Input10 1Output9NoteIn the first example you need to push the blue button once, and then push the red button once.In the second example, doubling the number is unnecessary, so we need to push the blue button nine times.这题好像以前做过。。。给你n和m，只能把n减一或乘二，问把n变到m需要多少步。网上很多题解都是BFS，看的我都吓坏了，现在CF的B都已经BFS了嘛。但实际上我局得类似贪心或者思维的做法更好。首先，对n操作和对m逆向操作是等价的，而当$n&gt;m$时n只能靠减自己来变成n，而乘二一定是比减一划算的，所以就是尽量乘二，不能乘二就减一。AC代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; int ans=0; while(n&lt;m) &#123; if(m&amp;1) &#123; m++; ans++; &#125; m&gt;&gt;=1; ans++; &#125; ans+=n-m; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;最近状态很差，只能刷刷水题找找手感和自信了……但是做水题都会卡壳，怎么办呢……]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>水</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA - 11468 Substring]]></title>
    <url>%2F2019%2F05%2F02%2FUVA-11468-Substring%2F</url>
    <content type="text"><![CDATA[Given a set of pattern strings, and a text, you have to find, if any of the pattern is a substring of thetext. If any of the pattern string can be found in text, then print ‘yes’, otherwise ‘no’ (without quotes).But, unfortunately, thats not what is asked here.The problem described above, requires a input file generator. The generator generates a text oflength L, by choosing L characters randomly. Probability of choosing each character is given as priori,and independent of choosing others.Now, given a set of patterns, calculate the probability of a valid program generating “no”.InputFirst line contains an integer T, the number of test cases. Each case starts with an integer K, thenumber of pattern strings. Next K lines each contain a pattern string, followed by an integer N,number of valid characters. Next N lines each contain a character and the probability of selecting thatcharacter, pi. Next an integer L, the length of the string generated. The generated text can consist ofonly the valid characters, given above.There will be a blank line after each test case.OutputFor each test case, output the number of test case, and the probability of getting a “no”.Constraints:• T ≤ 50• K ≤ 20• Length of each pattern string is between 1 and 20• Each pattern string consists of only alphanumeric characters (a to z, A to Z, 0 to 9)• Valid characters are all alphanumeric characters•∑pi = 1• L ≤ 100Sample Input21a2a 0.5b 0.522abab2a 0.2b 0.82Sample OutputCase #1: 0.250000Case #2: 0.840000这道题和POJ2778 这道题都有很大的相似之处，都是求出不含模板串的指定长度的文本串。区别有两个：文本串只含有指定字符，指定字符有概率出现，所以这是一道概率DP题……AC自动机真是什么都能加做的时候好像有很多想说，实际写的时候好像也没有什么好写的……判断是否含有模式串在poj2778讲过了，概率dp就是挺标准的正推概率，虽然之前做过概率dp的专题但是构造上是很不熟练……下次把专题的文章也搬过来吧。。。AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=410;const int maxm=64;struct node&#123; int ch[maxn][maxm]; int val[maxn]; int f[maxn]; int sz; double dp[maxn][110]; double p[maxm]; bool vis[maxn][maxn]; void init() &#123; sz=1; memset(ch[0],0,sizeof(ch[0])); val[0]=0; memset(p,0,sizeof(p)); memset(vis,false,sizeof(vis)); &#125; int idx(char c) &#123; if(c&gt;='a'&amp;&amp;c&lt;='z') return c-'a'; if(c&gt;='A'&amp;&amp;c&lt;='Z') return 26+c-'A'; if(c&gt;='0'&amp;&amp;c&lt;='9') return 52+c-'0'; &#125; void insert(char *s) &#123; int u=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); if (!ch[u][c]) &#123; memset(ch[sz],0,sizeof ch[sz]); val[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; val[u]=1; &#125; void build() &#123; queue&lt;int&gt;q; f[0]=0; for(int c=0;c&lt;maxm;c++) &#123; int u=ch[0][c]; if(u) &#123; f[u]=0; q.push(u); &#125; &#125; while(!q.empty()) &#123; int r=q.front();q.pop(); for(int c=0;c&lt;maxm;c++) &#123; int u=ch[r][c]; if(!u) &#123; ch[r][c]=ch[f[r]][c]; continue; &#125; q.push(u); int v=f[r]; f[u]=ch[v][c]; val[u]|=val[f[u]]; &#125; &#125; &#125; double solve(int u,int L) &#123; if(vis[u][L]) return dp[u][L]; if(!L) return dp[u][L]=1; vis[u][L]=true; dp[u][L]=0; for(int c=0;c&lt;maxm;c++) &#123; if(val[ch[u][c]]) continue; dp[u][L]+=p[c]*solve(ch[u][c],L-1); &#125; return dp[u][L]; &#125;&#125;ac;char s[30];int main()&#123; int T,kase=0; cin&gt;&gt;T; while(T--) &#123; ac.init(); int k; cin&gt;&gt;k; while(k--) &#123; scanf("%s",s); ac.insert(s); &#125; ac.build(); int n; cin&gt;&gt;n; while(n--) &#123; scanf("%s",s); scanf("%lf",&amp;ac.p[ac.idx(s[0])]); &#125; int L; cin&gt;&gt;L; printf("Case #%d: %.6lf\n",++kase,ac.solve(0,L)); &#125;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 2243 考研路茫茫――单词情结]]></title>
    <url>%2F2019%2F04%2F29%2FHDU-2243-%E8%80%83%E7%A0%94%E8%B7%AF%E8%8C%AB%E8%8C%AB%E2%80%95%E2%80%95%E5%8D%95%E8%AF%8D%E6%83%85%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背单词，始终是复习英语的重要环节。在荒废了3年大学生涯后，Lele也终于要开始背单词了。一天，Lele在某本单词书上看到了一个根据词根来背单词的方法。比如”ab”,放在单词前一般表示”相反，变坏，离去”等。于是Lele想，如果背了N个词根，那这些词根到底会不会在单词里出现呢。更确切的描述是：长度不超过L，只由小写字母组成的，至少包含一个词根的单词，一共可能有多少个呢？这里就不考虑单词是否有实际意义。比如一共有2个词根 aa 和 ab ，则可能存在104个长度不超过3的单词，分别为(2个) aa,ab,(26个)aaa,aab,aac…aaz,(26个)aba,abb,abc…abz,(25个)baa,caa,daa…zaa,(25个)bab,cab,dab…zab。这个只是很小的情况。而对于其他复杂点的情况，Lele实在是数不出来了，现在就请你帮帮他。Input本题目包含多组数据，请处理到文件结束。每组数据占两行。第一行有两个正整数N和L。(0&lt;N&lt;6,0&lt;L&lt;2^31)第二行有N个词根，每个词根仅由小写字母组成，长度不超过5。两个词根中间用一个空格分隔开。Output对于每组数据，请在一行里输出一共可能的单词数目。由于结果可能非常巨大，你只需要输出单词总数模2^64的值。Sample Input2 3aa ab1 2aSample Output10452这道题做的我要哭出来了……搞了好久好不容易把思路捋清楚了，自己写的代码却不停wa，最后耻辱借鉴了kuangbin的代码……这道题以后一定要搞清楚。首先我们要确定一个大问题：怎么求出可能的单词数目，也就是题目的要求。在上一道题里我们已经求过不含模板的n长度的串，放到这题，我们只要求出不含模板的长度小于n的串的和，然后用总和减去它就是含模板的串的长度就是最后的答案了。好像问题解决了？这才刚刚开始呢！这题的串长度可以达到2^31，如果老老实实算，不管是总和($26^1+26^2+…+26^n$)还是不包含的字串和（$M^1+M^2+…+M^n$ ,M为去除包含行列后的邻接矩阵）都会超时，所以两边都要优化。但是因为要求和。所以在POJ 2778 得到的L*L的矩阵中，需要增加一维，第L+1列全部为1这是kuangbin原话，不难使用也不难验证正确性，但是为什么呢？根据学长的讲解和我自己的理解，大概是这样：多了一列L+1，相当于放了一个虚拟节点，它的编号是L+1.这个节点可以存在字典树任何位置，因此它会“吞步”，意思说你走到它需要花n步(n为矩阵的幂)，但实际储存的是步数小于n的走法数量，因为这个节点不存在，走到它的实际是步数小于n的走法。当然自己是不能走到自己的，所以求出来的要减一。受到队友的启发，我想到，如果把整个矩阵M看成一个整体的话，加一位即$$\left{\begin{matrix}M &amp; 1 \0 &amp; 1 \\end{matrix}\right}$$乘自己即得到$$\left{\begin{matrix}M^2 &amp; M+1 \0 &amp; 1 \\end{matrix}\right}$$再乘就是$$\left{\begin{matrix}M^3 &amp; M^2+M+1 \0 &amp; 1 \\end{matrix}\right}$$这实际就是矩阵快速幂的递推用法！最后结果减1也是因为递推到最后结果是多了1的，刚刚好，就很妙。然后就是总序列的求法了，这个就是很干脆利落的真·矩阵快速幂了，定义f[n]=1 + 26^1 + 26^2 +…26^nf[n]=26*f[n-1]+1{f[n] 1} = {f[n-1] 1}[26 0;1 1]就能利用矩阵快速幂求出最后的解惹。最后还有一个问题，答案要对$2^{64}$取模,只要把数据开成unsigned long long就能自然地解决这个问题。然而讲了那么多还是不知道之前的代码错在哪了……如果有好心人知道的话麻烦告诉我一下……AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347/*#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;struct Matrix&#123; ull mat[40][40]; int n; Matrix ()&#123;&#125; Matrix (int _n) &#123; n=_n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) mat[i][j]=0; &#125; Matrix operator *(const Matrix &amp;b)const &#123; Matrix ret=Matrix(n); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) ret.mat[i][j]+=mat[i][k]*b.mat[k][j]; return ret; &#125;&#125;;ull pow_m(ull a,int n)&#123; ull ret=1; ull tmp=a; while(n) &#123; if(n&amp;1) ret*=tmp; tmp*=tmp; n&gt;&gt;=1; &#125; return ret;&#125;Matrix pow(Matrix a,int n)&#123; Matrix ret=Matrix(a.n); for(int i=0;i&lt;a.n;i++) ret.mat[i][i]=1; Matrix tmp=a; while(n) &#123; if(n&amp;1) ret=ret*tmp; tmp=tmp*tmp; n&gt;&gt;=1; &#125; return ret;&#125;const int maxn=40;const int maxm=26;const int N=120;struct node&#123; int ch[maxn][maxm],val[maxn],f[maxn],last[maxn],sz; void clear() &#123; sz=1;memset(ch[0],0,sizeof(ch[0])); &#125; int idx(char c) &#123; return c-'a'; &#125; void insert(char *s,int v) &#123; int u=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); if(!ch[u][c]) &#123; memset(ch[sz],0,sizeof(ch[sz])); val[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; val[u]=1; &#125; void build() &#123; queue&lt;int&gt;q; f[0]=0; for(int c=0;c&lt;maxm;c++) &#123; int u=ch[0][c]; if(u) &#123; f[u]=last[u]=0; q.push(u); &#125; &#125; while(!q.empty()) &#123; int r=q.front();q.pop(); for(int c=0;c&lt;maxm;c++) &#123; int u=ch[r][c]; if(!u) &#123; ch[r][c]=ch[f[r]][c]; val[r]=val[r]||val[f[r]]; continue; &#125; q.push(u); f[u]=ch[f[u]][c]; last[u]=val[f[u]]?f[u]:last[f[u]]; &#125; &#125; &#125;&#125;ac;//ull a[N][N];int n;Matrix init()&#123; n=ac.sz; Matrix ret=Matrix(n+1); int u; //memset(a,0,sizeof(a)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;maxm;j++) &#123; u=ac.ch[i][j]; if(!ac.val[u]) ret.mat[i][u]++; &#125; for(int i=0;i&lt;n+1;i++) ret.mat[i][n]=1; return ret;&#125;int main()&#123; char s[10]; int m,L; //ull b; while(cin&gt;&gt;m&gt;&gt;L) &#123; ac.clear(); for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s); ac.insert(s,i); &#125; ac.build(); Matrix a=init(); a=pow(a,L); ull res=0; for(int i=0;i&lt;a.n;i++) res+=a.mat[0][i]; res--; a=Matrix(2); a.mat[0][0]=26; a.mat[1][0]=a.mat[1][1]=1; a=pow(a,L); ull ans=a.mat[1][0]+a.mat[0][0]; ans--; ans-=res; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;*/#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;struct Matrix&#123; ull mat[40][40]; int n; Matrix ()&#123;&#125; Matrix (int _n) &#123; n=_n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) mat[i][j]=0; &#125; Matrix operator *(const Matrix &amp;b)const &#123; Matrix ret=Matrix(n); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) ret.mat[i][j]+=mat[i][k]*b.mat[k][j]; return ret; &#125;&#125;;ull pow_m(ull a,int n)&#123; ull ret=1; ull tmp=a; while(n) &#123; if(n&amp;1) ret*=tmp; tmp*=tmp; n&gt;&gt;=1; &#125; return ret;&#125;Matrix pow(Matrix a,int n)&#123; Matrix ret=Matrix(a.n); for(int i=0;i&lt;a.n;i++) ret.mat[i][i]=1; Matrix tmp=a; while(n) &#123; if(n&amp;1) ret=ret*tmp; tmp=tmp*tmp; n&gt;&gt;=1; &#125; return ret;&#125;struct node&#123; int ch[40][26],f[40]; bool last[40]; int sz,root; int newnode() &#123; for(int i=0;i&lt;26;i++) ch[sz][i]=-1; last[sz++]=false; return sz-1; &#125; void init() &#123; sz=0; root=newnode(); &#125; void insert(char *s) &#123; int now=root; for(int i=0;s[i];i++) &#123; if(ch[now][s[i]-'a']==-1) ch[now][s[i]-'a']=newnode(); now=ch[now][s[i]-'a']; &#125; last[now]=true; &#125; void build() &#123; queue&lt;int&gt;q; f[root]=root; for(int i=0;i&lt;26;i++) if(ch[root][i]==-1) ch[root][i]=root; else &#123; f[ch[root][i]]=root; q.push(ch[root][i]); &#125; while(!q.empty()) &#123; int now=q.front(); q.pop(); if(last[f[now]]) last[now]=true; for(int i=0;i&lt;26;i++) if(ch[now][i]==-1) ch[now][i]=ch[f[now]][i]; else &#123; f[ch[now][i]]=ch[f[now]][i]; q.push(ch[now][i]); &#125; &#125; &#125; Matrix getM() &#123; Matrix ret=Matrix(sz+1); for(int i=0;i&lt;sz;i++) for(int j=0;j&lt;26;j++) if(last[ch[i][j]]==false) ret.mat[i][ch[i][j]]++; for(int i=0;i&lt;sz+1;i++) ret.mat[i][sz]=1; return ret; &#125;&#125;ac;int main()&#123; char s[10]; int m,L; //ull b; while(cin&gt;&gt;m&gt;&gt;L) &#123; ac.init(); for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s); ac.insert(s); &#125; ac.build(); Matrix a=ac.getM(); a=pow(a,L); ull res=0; for(int i=0;i&lt;a.n;i++) res+=a.mat[0][i]; res--; a=Matrix(2); a.mat[0][0]=26; a.mat[1][0]=a.mat[1][1]=1; a=pow(a,L); ull ans=a.mat[1][0]+a.mat[0][0]; ans--; ans-=res; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>标记</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive - 4670 Dominating Patterns]]></title>
    <url>%2F2019%2F04%2F27%2F%C2%96%C2%96%C2%96UVALive-4670-Dominating-Patterns%2F</url>
    <content type="text"><![CDATA[The archaeologists are going to decipher a very mysterious “language”. Now, they know many languagepatterns; each pattern can be treated as a string on English letters (only lower case). As a sub string,these patterns may appear more than one times in a large text string (also only lower case Englishletters).What matters most is that which patterns are the dominating patterns. Dominating pattern is thepattern whose appearing times is not less than other patterns.It is your job to find the dominating pattern(s) and their appearing times.InputThe entire input contains multi cases. The first line of each case is an integer, which is the number ofpatterns N, 1 ≤ N ≤ 150. Each of the following N lines contains one pattern, whose length is in range[1, 70]. The rest of the case is one line contains a large string as the text to lookup, whose length is upto 106.At the end of the input file, number ‘0’ indicates the end of input file.OutputFor each of the input cases, output the appearing times of the dominating pattern(s). If there are morethan one dominating pattern, output them in separate lines; and keep their input order to the output.Sample Input2abababababababac6betaalphahahadeltadedetatadedeltalphahahahototatalpha0Sample Output4aba2alphahaha这题是个AC自动机模板题了，和前面的病毒侵袭很像。唯一的不同就是用map映射的字符串，大概是为了不重复？有点意义不明。今天做个水的 明天有个思索了好久的不知道能不能搞出来AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;const int maxm=26;map&lt;string,int&gt;ms;int cnt[160];struct node&#123; int ch[maxn][maxm],sz; int last[maxn],f[maxn],val[maxn]; void clear() &#123; sz=1; memset(ch[0],0,sizeof(ch[0])); memset(cnt,0,sizeof(cnt)); ms.clear(); &#125; int idx(char c) &#123; return c-'a'; &#125; void insert(char *s,int v) &#123; int u=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); if(!ch[u][c]) &#123; memset(ch[sz],0,sizeof(ch[sz])); val[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; val[u]=v; ms[string(s)]=v; &#125; void build() &#123; queue&lt;int&gt;q; f[0]=0; for(int c=0;c&lt;maxm;c++) &#123; int u=ch[0][c]; if(u) &#123; f[u]=0; q.push(u); last[u]=0; &#125; &#125; while(!q.empty()) &#123; int r=q.front();q.pop(); for(int c=0;c&lt;maxm;c++) &#123; int u=ch[r][c]; if(!u) &#123; ch[r][c]=ch[f[r]][c]; continue; &#125; q.push(u); f[u]=ch[f[r]][c]; last[u]=val[f[u]]?f[u]:last[f[u]]; &#125; &#125; &#125; void find(char *s) &#123; int j=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); j=ch[j][c]; if(val[j]) print(j); else if(last[j]) print(last[j]); &#125; &#125; void print(int j) &#123; if(j) &#123; cnt[val[j]]++; print(last[j]); &#125; &#125;&#125;ac;char s[200][80],text[maxn];int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n) &#123; ac.clear(); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s[i]); ac.insert(s[i],i); &#125; ac.build(); scanf("%s",text); ac.find(text); int maxx=-1; for(int i=1;i&lt;=n;i++) maxx=max(maxx,cnt[i]); cout&lt;&lt;maxx&lt;&lt;endl; for(int i=1;i&lt;=n;i++) if(cnt[ms[string(s[i])]]==maxx) cout&lt;&lt;s[i]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ - 2778 DNA Sequence及对AC自动机的一些理解]]></title>
    <url>%2F2019%2F04%2F26%2FPOJ-2778-DNA-Sequence%E5%8F%8A%E5%AF%B9AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[It’s well known that DNA Sequence is a sequence only contains A, C, T and G, and it’s very useful to analyze a segment of DNA Sequence，For example, if a animal’s DNA sequence contains segment ATC then it may mean that the animal may have a genetic disease. Until now scientists have found several those segments, the problem is how many kinds of DNA sequences of a species don’t contain those segments.Suppose that DNA sequences of a species is a sequence that consist of A, C, T and G，and the length of sequences is a given integer n.InputFirst line contains two integer m (0 &lt;= m &lt;= 10), n (1 &lt;= n &lt;=2000000000). Here, m is the number of genetic disease segment, and n is the length of sequences.Next m lines each line contain a DNA genetic disease segment, and length of these segments is not larger than 10.OutputAn integer, the number of DNA sequences, mod 100000.Sample Input4 3ATACAGAASample Output36在谈这题之前，先从我的理解谈谈AC自动机。现在给了你若干个字符串：acaezdgbcdbedgbcdge。。。zd然后输入字符串，求出输入的字符串中出现上列给出字符串的个数。这个问题有很多要考虑的地方，先考虑一个：开数组存字符串太低效了，时间空间上都是。查起来慢，存起来还占内存。这时候就需要字典树出马了。字典树不仅储存省地方效率还很高。这时候再考虑一种情况：输入字符串为aezd显然，它只含有zd一个给出的字符串，但是我们却要老老实实遍历整个字典树才能找到它，能不能优化它呢？注意到aezdg和zd长得很像，我们可以使用kmp的思想：判断到a—&gt;e—&gt;z—&gt;d时，下一个节点是g，失配，我们用一个失配指针，让d失配时指向zd，这不就减少遍历了吗。一个大概的例子所以，一个字符串失配时指向的字符串有两个性质：1.指向的字符串比自己短2.两个字符串有相同的后缀，如abcd可以指向bcd,cd,d也就是说，指向的字符串一定包含于失配的字符串。通过层层比较，就可以提前把相同后缀的匹配完成，再把没有相同后缀的节点失配指向根节点，就像kmp一样，查询指针不用往回走。本题题解大概如下这题运用到了我们前面推导的性质：因为指向的字符串包含与失配字符串，所以指向的字符串含有病毒子串时，失配（这题中不是真失配，只是做一个指向）字符串一定也含有病毒子串。然后就是若干线性代数知识。这题虽说用到了矩阵快速幂，但是只是普通的一个运用，和普通快速幂无差。等真要用到矩阵快速幂优化递推式的时候再仔细学吧……AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;const int maxn=110;const int maxm=4;const int mod=100000;const int maxnn=200;struct node&#123; int ch[maxn][maxm],val[maxn],f[maxn],last[maxn],sz; void clear() &#123; sz=1; memset(ch[0],0,sizeof(ch[0])); &#125; int idx(char c) &#123; if(c=='A') return 0; if(c=='C') return 1; if(c=='T') return 2; return 3; &#125; void insert(char *s,int v) &#123; int u=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); if(!ch[u][c]) &#123; memset(ch[sz],0,sizeof(ch[sz])); val[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; val[u]=1; &#125; void build() &#123; queue&lt;int&gt;q; f[0]=0; for(int c=0;c&lt;maxm;c++) &#123; int u=ch[0][c]; if(u) &#123; f[u]=last[u]=0; q.push(u); &#125; &#125; while(!q.empty()) &#123; int r=q.front();q.pop(); for(int c=0;c&lt;maxm;c++) &#123; int u=ch[r][c]; if(!u) &#123; ch[r][c]=ch[f[r]][c]; val[r]=val[r]||val[f[r]]; continue; &#125; q.push(u); f[u]=ch[f[r]][c]; last[u]=val[f[u]]?f[u]:last[f[u]]; &#125; &#125; &#125;&#125;ac;ll a[maxnn][maxnn];int n;void mul(ll a[][maxnn],ll b[][maxnn],ll c[][maxnn])&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) &#123; c[i][j]=0; for(int k=0;k&lt;n;k++) c[i][j]=(c[i][j]+a[i][k]*b[k][j])%mod; &#125;&#125;void copy(ll d[][maxnn],ll s[][maxnn])&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) d[i][j]=s[i][j];&#125;void pow(ll a[][maxnn],ll b)&#123; ll t[maxnn][maxnn],ret[maxnn][maxnn]; for(int i=0;i&lt;n;i++) ret[i][i]=1; while(b) &#123; if(b&amp;1) &#123; mul(ret,a,t); copy(ret,t); &#125; mul(a,a,t); copy(a,t); b&gt;&gt;=1; &#125; copy(a,ret);&#125;void init()&#123; n=ac.sz; int u; memset(a,0,sizeof(a)); for(int i=0;i&lt;n;i++) if(!ac.val[i]) for(int j=0;j&lt;4;j++) &#123; u=ac.ch[i][j]; if(!ac.val[u]) a[i][u]++; &#125;&#125;int main()&#123; char s[12]; int m; ll b; while(cin&gt;&gt;m&gt;&gt;b) &#123; ac.clear(); for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s); ac.insert(s,i); &#125; ac.build(); init(); pow(a,b); ll sum=0; for(int i=0;i&lt;n;i++) sum=(sum+a[0][i])%mod; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 3065 病毒侵袭持续中]]></title>
    <url>%2F2019%2F04%2F22%2FHDU-3065-%E7%97%85%E6%AF%92%E4%BE%B5%E8%A2%AD%E6%8C%81%E7%BB%AD%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[小t非常感谢大家帮忙解决了他的上一个问题。然而病毒侵袭持续中。在小t的不懈努力下，他发现了网路中的“万恶之源”。这是一个庞大的病毒网站，他有着好多好多的病毒，但是这个网站包含的病毒很奇怪，这些病毒的特征码很短，而且只包含“英文大写字符”。当然小t好想好想为民除害，但是小t从来不打没有准备的战争。知己知彼，百战不殆，小t首先要做的是知道这个病毒网站特征：包含多少不同的病毒，每种病毒出现了多少次。大家能再帮帮他吗？Input第一行，一个整数N（1&lt;=N&lt;=1000），表示病毒特征码的个数。接下来N行，每行表示一个病毒特征码，特征码字符串长度在1—50之间，并且只包含“英文大写字符”。任意两个病毒特征码，不会完全相同。在这之后一行，表示“万恶之源”网站源码，源码字符串长度在2000000之内。字符串中字符都是ASCII码可见字符（不包括回车）。Output按以下格式每行一个，输出每个病毒出现次数。未出现的病毒不需要输出。病毒特征码: 出现次数冒号后有一个空格，按病毒特征码的输入顺序进行输出。Sample Input3AABBCCooxxCC%dAAAoen….ENDSample OutputAA: 2CC: 1HintHit：题目描述中没有被提及的所有情况都应该进行考虑。比如两个病毒特征码可能有相互包含或者有重叠的特征码段。计数策略也可一定程度上从Sample中推测。这道题表面上就是统计每个特征码的出现次数，但是实际上险象环生：网站源码可能长达两百万，还有很多的无效字符！这就需要预处理了，首先得用gets()进行输入，其次要把无关的字符全都去掉只留下大写字符，代码中用的方法是多开一个字符数组，如果是连续大写字母就存起来，如果断了就把存起来的查一发。下午做的时候抽了，想不到怎么保证cnt和特征码同步，后来想想val里储存的就是特征码的编号嘛，把val中的编号对应cnt++就完事了。据说c++11没有gets()了……那以后该怎么办呢……AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=6e4+10;const int maxm=30;char s[1010][60],t[2000010],a[2000010];int n,cnt[1010];struct node&#123; int ch[maxn][maxm],sz; int val[maxn],last[maxn],f[maxn]; void clear()&#123; sz=1;memset(ch[0],0,sizeof(ch));&#125; int idx(char c) &#123;return c-'A';&#125; void insert(char *s,int v) &#123; int u=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); if(!ch[u][c]) &#123; memset(ch[sz],0,sizeof(ch[sz])); val[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; val[u]=v; &#125; void get_fail() &#123; queue&lt;int&gt;q; f[0]=0; for(int c=0;c&lt;maxm;c++) &#123; int u=ch[0][c]; if(u) &#123; f[u]=0; q.push(u); last[u]=0; &#125; &#125; while(!q.empty()) &#123; int r=q.front();q.pop(); for(int c=0;c&lt;maxm;c++) &#123; int u=ch[r][c]; if(!u) &#123; ch[r][c]=ch[f[r]][c]; continue; &#125; q.push(u); f[u]=ch[f[r]][c]; last[u]=val[f[u]]?f[u]:last[f[u]]; &#125; &#125; &#125; void find(char *s) &#123; int j=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); j=ch[j][c]; if(val[j]) print(j); else if(last[j]) print(last[j]); &#125; &#125; void print(int j) &#123; if(j) &#123; cnt[val[j]]++; print(last[j]); &#125; &#125;&#125;ac;int main()&#123; while(cin&gt;&gt;n) &#123; ac.clear(); memset(cnt,0,sizeof(cnt)); getchar(); for(int i=1;i&lt;=n;i++) &#123; gets(s[i]); ac.insert(s[i],i); &#125; ac.get_fail(); gets(t); int j=0; bool flag=false; for(int i=0;t[i];i++) &#123; if(t[i]&lt;='Z'&amp;&amp;t[i]&gt;='A') &#123; flag=true; a[j++]=t[i]; &#125; else if (flag) &#123; a[j]=0;j=0; flag=false; ac.find(a); &#125; &#125; if(flag) &#123; a[j]=0;j=0; flag=false;ac.find(a); &#125; for(int i=1;i&lt;=n;i++) if(cnt[i]&amp;&amp;s[i][0]) printf("%s: %d\n", s[i], cnt[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 2896 病毒侵袭]]></title>
    <url>%2F2019%2F04%2F22%2FHDU-2896-%E7%97%85%E6%AF%92%E4%BE%B5%E8%A2%AD%2F</url>
    <content type="text"><![CDATA[当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~Input第一行，一个整数N（1&lt;=N&lt;=500），表示病毒特征码的个数。接下来N行，每行表示一个病毒特征码，特征码字符串长度在20—200之间。每个病毒都有一个编号，依此为1—N。不同编号的病毒特征码不会相同。在这之后一行，有一个整数M（1&lt;=M&lt;=1000），表示网站数。接下来M行，每行表示一个网站源码，源码字符串长度在7000—10000之间。每个网站都有一个编号，依此为1—M。以上字符串中字符都是ASCII码可见字符（不包括回车）。Output依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。web 网站编号: 病毒编号 病毒编号 …冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。最后一行输出统计信息，如下格式total: 带病毒网站数冒号后有一个空格。Sample Input3aaabbbccc2aaabbbcccbbaaccSample Outputweb 1: 1 2 3total: 1依然是AC自动机的板子，和上一题的区别是上一题只要统计出现单词的个数，这次要统计全部出现的编号。用一个vector把全部出现的都推进去，再用unique去重就行了###AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=6e4+10;const int maxm=130;vector&lt;int&gt;ans;struct node&#123; int ch[maxn][maxm],sz; int val[maxn],last[maxn],f[maxn]; void clear()&#123; sz=1;memset(ch[0],0,sizeof(ch));&#125; int idx(char c) &#123;return c;&#125; void insert(char *s,int v) &#123; int u=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); if(!ch[u][c]) &#123; memset(ch[sz],0,sizeof(ch[sz])); val[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; val[u]=v; &#125; void get_fail() &#123; queue&lt;int&gt;q; f[0]=0; for(int c=0;c&lt;maxm;c++) &#123; int u=ch[0][c]; if(u) &#123; f[u]=0; q.push(u); last[u]=0; &#125; &#125; while(!q.empty()) &#123; int r=q.front();q.pop(); for(int c=0;c&lt;maxm;c++) &#123; int u=ch[r][c]; if(!u) &#123; ch[r][c]=ch[f[r]][c]; continue; &#125; q.push(u); f[u]=ch[f[r]][c]; last[u]=val[f[u]]?f[u]:last[f[u]]; &#125; &#125; &#125; void find(char *s) &#123; int j=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); j=ch[j][c]; if(val[j]) print(j); else if(last[j]) print(last[j]); &#125; &#125; void print(int j) &#123; if(j) &#123; ans.push_back(val[j]); print(last[j]); &#125; &#125;&#125;ac;char s[250],t[10010];int main()&#123; int n,m; while(cin&gt;&gt;n) &#123; ac.clear(); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s); ac.insert(s,i); &#125; ac.get_fail(); cin&gt;&gt;m; int tot=0; for(int i=1;i&lt;=m;i++) &#123; ans.clear(); scanf("%s",t); ac.find(t); if(ans.size()==0) continue; sort(ans.begin(),ans.end()); int k=unique(ans.begin(),ans.end())-ans.begin(); printf("web %d:",i); for(int j=0;j&lt;k;j++) printf(" %d",ans[j]); cout&lt;&lt;endl; tot++; &#125; printf("total: %d\n",tot); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 2222 Keywords Search]]></title>
    <url>%2F2019%2F04%2F21%2FHDU-2222-Keywords-Search%2F</url>
    <content type="text"><![CDATA[In the modern time, Search engine came into the life of everybody like Google, Baidu, etc.Wiskey also wants to bring this feature to his image retrieval system.Every image have a long description, when users type some keywords to find the image, the system will match the keywords with description of image and show the image which the most keywords be matched.To simplify the problem, giving you a description of image, and some keywords, you should tell me how many keywords will be match.InputFirst line will contain one integer means how many cases will follow by.Each case will contain two integers N means the number of keywords and N keywords follow. (N &lt;= 10000)Each keyword will only contains characters ‘a’-‘z’, and the length will be not longer than 50.The last line is the description, and the length will be not longer than 1000000.OutputPrint how many keywords are contained in the description.Sample Input15shehesayshrheryasherhsSample Output3AC自动机牛逼！这是我做的第一道AC自动机的题目了，心里还是有点小激动。因为AC自动机这个名词一直萦绕我的耳边，作为一个万能而高端的算法存在。如今我终于也能触及这算法的一个小角了。学习AC自动机的前提是字典树和kmp，更准确的说是kmp的失配算法。这两块一定要好好掌握，我就因为字典树掌握的不太好吃了亏。推荐几篇博文：这个PPT深入浅出，对失配指针的寻找讲解很生动上古神触的博客，讲解非常到位，可惜是指针写法最后的写法是用蓝书的板子改的，我个人感觉不错，数组和结构体保证了整体代码的可读性和简洁，count数组即val数组，在本题中用以维护以j为结尾的单词个数我说啥胡话呢，以j为结尾的单词当然是唯一的，维护的是该单词的出现次数。AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=240000+10;const int maxm=26;int cnt;struct AC_Automata&#123; int ch[maxn][maxm],sz; int last[maxn],f[maxn],count[maxn]; void clear() &#123; sz=1;memset(ch[0],0,sizeof(ch[0])); &#125; int idx(char c)&#123;return c-'a';&#125;; void insert(char *s,int v) &#123; int u=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); if(!ch[u][c]) &#123; memset(ch[sz],0,sizeof(ch[sz])); count[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; count[u]++; //val[u]=v; &#125; void build() &#123; queue&lt;int&gt;q; f[0]=0; for(int c=0;c&lt;maxm;c++) &#123; int u=ch[0][c]; if(u) &#123; f[u]=0; q.push(u);last[u]=0; &#125; &#125; while(!q.empty()) &#123; int r=q.front();q.pop(); for(int c=0;c&lt;maxm;c++) &#123; int u=ch[r][c]; if(!u) &#123; ch[r][c]=ch[f[r]][c]; continue; &#125; q.push(u); int v=f[r]; f[u]=ch[v][c]; last[u]=count[f[u]]?f[u]:last[f[u]]; &#125; &#125; &#125; void find(char *s) &#123; int j=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); j=ch[j][c]; if(count[j]) print(j); else if(last[j]) print(last[j]); &#125; &#125; void print(int j) &#123; if(j) &#123; cnt+=count[j]; count[j]=0; print(last[j]); &#125; &#125;&#125;ac;char s[55],text[1000010];int main()&#123; int n,T; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n; ac.clear(); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s); ac.insert(s,i); &#125; ac.build(); cnt=0; scanf("%s",text); ac.find(text); printf("%d\n",cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive - 3026 Period]]></title>
    <url>%2F2019%2F04%2F21%2FUVALive-3026-Period%2F</url>
    <content type="text"><![CDATA[For each prefix of a given string S with N characters (each character has an ASCII code between 97 and126, inclusive), we want to know whether the prefix is a periodic string. That is, for each i (2 ≤ i ≤ N)we want to know the largest K &gt; 1 (if there is one) such that the prefix of S with length i can bewritten as AK, that is A concatenated K times, for some string A. Of course, we also want to knowthe period K.InputThe input file consists of several test cases. Each test case consists of two lines. The first one containsN (2 ≤ N ≤ 1000000) the size of the string S. The second line contains the string S. The input fileends with a line, having the number zero on it.OutputFor each test case, output ‘Test case #’ and the consecutive test case number on a single line; then, foreach prefix with length i that has a period K &gt; 1, output the prefix size i and the period K separatedby a single space; the prefix sizes must be in increasing order. Print a blank line after each test case.Sample Input3aaa12aabaabaabaab0Sample OutputTest case #12 23 3Test case #22 26 29 312 4这题说是kmp，其实是用到了一部分kmp的思想。kmp网上的介绍很多了不做赘述，这里用到的实际是next数组的思想。很容易想到，如果你和一个子串不能匹配，那么和他相同的子串你也不能匹配。next数组的作用就是告诉程序，我这前边有多少个字符是已经出现过了，你看着匹配吧。放到这个程序里，就是你已经知道next数组里重复的个数了，如果k(i-next[i])=i成立，那就是一个循环节uva居然不能用next命名 搞得我ce了一次AC代码：12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int f[maxn];string p;int main()&#123; int n,kase=0; while(cin&gt;&gt;n&amp;&amp;n) &#123; cin&gt;&gt;p; string t; f[0]=0; f[1]=0; for(int i=1;i&lt;n;i++) &#123; int j=f[i]; while(j&amp;&amp;p[i]!=p[j]) j=f[j]; f[i+1]=(p[i]==p[j]?j+1:0); &#125; printf("Test case #%d\n",++kase); for(int i=2;i&lt;=n;i++) if(f[i]&gt;0 &amp;&amp; i%(i-f[i])==0) cout&lt;&lt;i&lt;&lt;' '&lt;&lt;i/(i-f[i])&lt;&lt;endl; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive - 3942 Remember the Word]]></title>
    <url>%2F2019%2F04%2F19%2FUVALive-3942-Remember-the-Word%2F</url>
    <content type="text"><![CDATA[Neal is very curious about combinatorial problems, and now here comes a problem about words. Knowing that Ray has a photographic memory and this may not trouble him, Neal gives it to Jiejie.Since Jiejie can’t remember numbers clearly, he just uses sticks to help himself. Allowing for Jiejie’sonly 20071027 sticks, he can only record the remainders of the numbers divided by total amount ofsticks.The problem is as follows: a word needs to be divided into small pieces in such a way that eachpiece is from some given set of words. Given a word and the set of words, Jiejie should calculate thenumber of ways the given word can be divided, using the words in the set.InputThe input file contains multiple test cases. For each test case: the first line contains the given wordwhose length is no more than 300 000.The second line contains an integer S, 1 ≤ S ≤ 4000.Each of the following S lines contains one word from the set. Each word will be at most 100characters long. There will be no two identical words and all letters in the words will be lowercase.There is a blank line between consecutive test cases.You should proceed to the end of file.OutputFor each test case, output the number, as described above, from the task description modulo 20071027.Sample Inputabcd4abcdabSample OutputCase 1: 2很容易能反应出这是一道DP，设dp(i)表示原字符串的子串[i,len-1]的划分方案数，那么dp(i)=sum{dp(i+len(x)) | x是某个单词，同时x为[i,len-1]的前缀 }，边界是dp(len)=1。但是问题是怎么找出是前缀的x，这时候就要使用前缀树了。说是这么说 我做的还是迷迷糊糊的AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int mod=20071027;const int maxn=4e5+10;string p,s;int trie[maxn][26],tot;int deep[maxn];bool isword[maxn];int dp[maxn];int num,len;void init()&#123; len=p.size(); tot=0; memset(trie,0,sizeof(trie)); memset(isword,0,sizeof(isword)); memset(deep,0,sizeof(deep)); memset(dp,-1,sizeof(dp));&#125;int dfs(int i)&#123; if(i==len) return 1; if(dp[i]!=-1) return dp[i]; int node=0,ans=0; for(int j=i;j&lt;len;++j) &#123; int id=p[j]-'a'; node=trie[node][id]; if(isword[node]) ans=(ans+dfs(i+deep[node]))%mod; if(!node) break; &#125; return dp[i]=ans;&#125;void insert()&#123; int node=0; for(int i=0;s[i];i++) &#123; int id=s[i]-'a'; if(!trie[node][id]) &#123; trie[node][id]=++tot; deep[trie[node][id]]=deep[node]+1; &#125; node=trie[node][id]; &#125; isword[node]=true;&#125;int main()&#123; int kase=0; while(cin&gt;&gt;p) &#123; init(); cin&gt;&gt;num; while(num--) &#123; cin&gt;&gt;s; insert(); &#125; int ans=dfs(0); printf("Case %d: %d\n",++kase,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ - 3264 Balanced Lineup]]></title>
    <url>%2F2019%2F04%2F17%2FPOJ-3264-Balanced-Lineup%2F</url>
    <content type="text"><![CDATA[For the daily milking, Farmer John’s N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height.Farmer John has made a list of Q (1 ≤ Q ≤ 200,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.InputLine 1: Two space-separated integers, N and Q.Lines 2.. N+1: Line i+1 contains a single integer that is the height of cow iLines N+2.. N+ Q+1: Two integers A and B (1 ≤ A ≤ B ≤ N), representing the range of cows from A to B inclusive.OutputLines 1.. Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range.Sample Input6 31734251 54 62 2Sample Output630这道题和前面的题相比反倒难度下降了……就是维护最大值和最小值，没了，甚至没有更新只有查询。。。。。。AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn=7e4+10;struct Node&#123; int l,r; int minn,maxx;&#125;tree;Node node[4*maxn];int num[maxn],minn,maxx;void build(int o,int l,int r)&#123; node[o].l=l;node[o].r=r; if(node[o].l==node[o].r) &#123; node[o].maxx=node[o].minn=num[l]; return; &#125; int mid=(node[o].l+node[o].r)/2; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); node[o].maxx=max(node[o&lt;&lt;1].maxx,node[o&lt;&lt;1|1].maxx); node[o].minn=min(node[o&lt;&lt;1].minn,node[o&lt;&lt;1|1].minn);&#125;void query(int o,int l,int r)&#123; if(node[o].l==l&amp;&amp;node[o].r==r) &#123; maxx=max(node[o].maxx,maxx); minn=min(node[o].minn,minn); return; &#125; int mid=(node[o].l+node[o].r)/2; if(l&gt;mid) query(o&lt;&lt;1|1,l,r); else if(r&lt;=mid) query(o&lt;&lt;1,l,r); else &#123; query(o&lt;&lt;1,l,mid); query(o&lt;&lt;1|1,mid+1,r); &#125;&#125;int main()&#123; int n,m,a,b; memset(node,0,sizeof(node)); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;num[i]); build(1,1,n); while(m--) &#123; scanf("%d%d",&amp;a,&amp;b); maxx=0;minn=0x3f3f3f3f; query(1,a,b); cout&lt;&lt;maxx-minn&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ - 1610 Count the Colors]]></title>
    <url>%2F2019%2F04%2F17%2FZOJ-1610-Count-the-Colors%2F</url>
    <content type="text"><![CDATA[Painting some colored segments on a line, some previously painted segments may be covered by some the subsequent ones.Your task is counting the segments of different colors you can see at last.InputThe first line of each data set contains exactly one integer n, 1 &lt;= n &lt;= 8000, equal to the number of colored segments.Each of the following n lines consists of exactly 3 nonnegative integers separated by single spaces:x1 x2 cx1 and x2 indicate the left endpoint and right endpoint of the segment, c indicates the color of the segment.All the numbers are in the range [0, 8000], and they are all integers.Input may contain several data set, process to the end of file.OutputEach line of the output should contain a color index that can be seen from the top, following the count of the segments of this color, they should be printed according to the color index.If some color can’t be seen, you shouldn’t print it.Print a blank line after every dataset.Sample Input50 4 40 3 13 4 20 2 20 2 340 1 13 4 11 3 21 3 160 1 01 2 12 3 11 2 02 3 01 2 1Sample Output1 12 13 11 10 21 1这题本身是一个区间覆盖的题，但是存在边界的问题，所以在数据处理上要注意边界的位置。AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=8e3+10;struct Node&#123; int l,r; int color;&#125;node[4*maxn];int color[maxn];int temp;void build(int i,int l,int r)&#123; node[i].l=l; node[i].r=r; node[i].color=-1; if(l+1==r) return; int mid=(l+r)&gt;&gt;1; build(i&lt;&lt;1,l,mid); build(i&lt;&lt;1|1,mid,r);&#125;void insert(int i,int l,int r,int c)&#123; if(l==r) return; if(node[i].color==c) return; if(l&lt;=node[i].l&amp;&amp;r&gt;=node[i].r) &#123; node[i].color=c; return; &#125; if(node[i].color&gt;=0) &#123; node[i&lt;&lt;1].color=node[i].color; node[i&lt;&lt;1|1].color=node[i].color; node[i].color=-2; &#125; int mid=(node[i].l+node[i].r)&gt;&gt;1; if(r&lt;=mid) insert(i&lt;&lt;1,l,r,c); else if(l&gt;=mid) insert(i&lt;&lt;1|1,l,r,c); else &#123; insert(i&lt;&lt;1,l,mid,c); insert(i&lt;&lt;1|1,mid,r,c); &#125; node[i].color=-2;&#125;void count(int i)&#123; if(node[i].color==-1) &#123; temp=-1; return; &#125; if(node[i].color!=-2) &#123; if(node[i].color!=temp) &#123; color[node[i].color]++; temp=node[i].color; &#125; return; &#125; if(node[i].l+1!=node[i].r) &#123; count(i&lt;&lt;1); count((i&lt;&lt;1)|1); &#125;&#125;int main()&#123; int n,a,b,c; int maxx; while(cin&gt;&gt;n) &#123; build(1,0,8000); maxx=0; while(n--) &#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); insert(1,a,b,c); maxx=max(c,maxx); &#125; temp=-1; memset(color,0,sizeof(color)); count(1); for(int i=0;i&lt;=maxx;i++) if(color[i]) cout&lt;&lt;i&lt;&lt;' '&lt;&lt;color[i]&lt;&lt;endl; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1698 Just a Hook]]></title>
    <url>%2F2019%2F04%2F16%2FHDU-1698-Just-a-Hook%2F</url>
    <content type="text"><![CDATA[In the game of DotA, Pudge’s meat hook is actually the most horrible thing for most of the heroes. The hook is made up of several consecutive metallic sticks which are of the same length.Now Pudge wants to do some operations on the hook.Let us number the consecutive metallic sticks of the hook from 1 to N. For each operation, Pudge can change the consecutive metallic sticks, numbered from X to Y, into cupreous sticks, silver sticks or golden sticks.The total value of the hook is calculated as the sum of values of N metallic sticks. More precisely, the value for each kind of stick is calculated as follows:For each cupreous stick, the value is 1.For each silver stick, the value is 2.For each golden stick, the value is 3.Pudge wants to know the total value of the hook after performing the operations.You may consider the original hook is made up of cupreous sticks.InputThe input consists of several test cases. The first line of the input is the number of the cases. There are no more than 10 cases.For each case, the first line contains an integer N, 1&lt;=N&lt;=100,000, which is the number of the sticks of Pudge’s meat hook and the second line contains an integer Q, 0&lt;=Q&lt;=100,000, which is the number of the operations.Next Q lines, each line contains three integers X, Y, 1&lt;=X&lt;=Y&lt;=N, Z, 1&lt;=Z&lt;=3, which defines an operation: change the sticks numbered from X to Y into the metal kind Z, where Z=1 represents the cupreous kind, Z=2 represents the silver kind and Z=3 represents the golden kind.OutputFor each case, print a number in a line representing the total value of the hook after the operations. Use the format in the example.Sample Input11021 5 25 9 3Sample OutputCase 1: The total value of the hook is 24.这道题是线段树区间覆盖的板子题了（不带查询的板子题），蓝书上说的区间覆盖有点悬，但是实际上，只要有新的覆盖就把旧的延迟标记覆盖了就完事了。不过这也让我想到，如果有覆盖和更新并存的情况，也是直接处理就行吗……顺便吐槽 区间覆盖好像没一个确定的名字，搜半天搜不到，都是区间更新的AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int sum[4*maxn],ans[4*maxn];void pushup(int o)&#123; sum[o]=sum[o&lt;&lt;1]+sum[o&lt;&lt;1|1];&#125;void pushdown(int o,int l,int r)&#123; if(ans[o]) &#123; int m=l+(r-l)/2; ans[o&lt;&lt;1]=ans[o&lt;&lt;1|1]=ans[o]; sum[o&lt;&lt;1]=(m-l+1)*ans[o]; sum[o&lt;&lt;1|1]=(r-m)*ans[o]; ans[o]=0; &#125;&#125;void build(int l,int r,int o)&#123; int m=l+(r-l)/2; ans[o]=0; if(l==r) &#123; sum[o]=1; return; &#125; build(l,m,o&lt;&lt;1); build(m+1,r,o&lt;&lt;1|1); pushup(o);&#125;void update(int L,int R,int c,int l,int r,int o)&#123; int m=l+(r-l)/2; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; ans[o]=c; sum[o]=(r-l+1)*c; return; &#125; pushdown(o,l,r); if(L&lt;=m) update(L,R,c,l,m,o&lt;&lt;1); if(m&lt;R) update(L,R,c,m+1,r,o&lt;&lt;1|1); pushup(o);&#125;int main()&#123; int t; cin&gt;&gt;t; int kase=0; while(t--) &#123; int n,q; cin&gt;&gt;n&gt;&gt;q; build(1,n,1); while(q--) &#123; int l,r,c; scanf("%d%d%d",&amp;l,&amp;r,&amp;c); update(l,r,c,1,n,1); &#125; printf("Case %d: The total value of the hook is %d.\n",++kase,sum[1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ - 2528 Mayor's posters]]></title>
    <url>%2F2019%2F04%2F16%2FPOJ-2528-Mayor-s-posters%2F</url>
    <content type="text"><![CDATA[The citizens of Bytetown, AB, could not stand that the candidates in the mayoral election campaign have been placing their electoral posters at all places at their whim. The city council has finally decided to build an electoral wall for placing the posters and introduce the following rules:Every candidate can place exactly one poster on the wall.All posters are of the same height equal to the height of the wall; the width of a poster can be any integer number of bytes (byte is the unit of length in Bytetown).The wall is divided into segments and the width of each segment is one byte.Each poster must completely cover a contiguous number of wall segments.They have built a wall 10000000 bytes long (such that there is enough place for all candidates). When the electoral campaign was restarted, the candidates were placing their posters on the wall and their posters differed widely in width. Moreover, the candidates started placing their posters on wall segments already occupied by other posters. Everyone in Bytetown was curious whose posters will be visible (entirely or in part) on the last day before elections.Your task is to find the number of visible posters when all the posters are placed given the information about posters’ size, their place and order of placement on the electoral wall.InputThe first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 &lt;= n &lt;= 10000. The subsequent n lines describe the posters in the order in which they were placed. The i-th line among the n lines contains two integer numbers l i and ri which are the number of the wall segment occupied by the left end and the right end of the i-th poster, respectively. We know that for each 1 &lt;= i &lt;= n, 1 &lt;= l i &lt;= ri &lt;= 10000000. After the i-th poster is placed, it entirely covers all wall segments numbered l i, l i+1 ,… , ri.OutputFor each input data set print the number of visible posters after all the posters are placed.The picture below illustrates the case of the sample input.Sample Input151 42 68 103 47 10Sample Output4这道题……emmmmmm中间隔了个数学建模，实际我完全不知道自己做的是啥了，只知道这是线段树加数据离散化，然而数据离散化我也不会，问题很大。AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=4e4+5;int m,a[maxn];int idx[maxn];struct Paint&#123; int l,r;&#125;paint[maxn];struct Node&#123; int l,r; int val,lazy; void update(LL x) &#123; val=(r-l+1)*x; lazy=x; &#125;&#125;node[4*maxn];void pushdown(int root)&#123; if(node[root].lazy) &#123; node[root*2].update(node[root].lazy); node[root*2+1].update(node[root].lazy); node[root].lazy=0; &#125;&#125;void pushup(int root)&#123; node[root].val=max(node[root*2].val,node[root*2+1].val);&#125;void build(int root,int l,int r)&#123; node[root].l=l; node[root].r=r; node[root].val=0; node[root].lazy=0; if(l==r) node[root].val=a[l]; else &#123; int mid=l+(r-l)/2; build(root*2,l,mid); build(root*2+1,mid+1,r); pushup(root); &#125;&#125;void update(int root,int st,int ed,int val)&#123; if(st&gt;node[root].r||ed&lt;node[root].l) return ; if(st&lt;=node[root].l&amp;&amp;node[root].r&lt;=ed) node[root].update(val); else &#123; pushdown(root); update(root*2,st,ed,val); update(root*2+1,st,ed,val); pushup(root); &#125;&#125;int query(int root,int st,int ed)&#123; if(ed&lt;node[root].l||node[root].r&lt;st) return 0; if(st&lt;=node[root].l&amp;&amp;node[root].r&lt;=ed) return node[root].val; else &#123; pushdown(root); LL a=query(root*2,st,ed); LL b=query(root*2+1,st,ed); pushup(root); return max(a,b); &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;m; memset(a,0,sizeof(a)); int _size=0; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;paint[i].l,&amp;paint[i].r); idx[_size++]=paint[i].l; idx[_size++]=paint[i].l-1; idx[_size++]=paint[i].r; idx[_size++]=paint[i].r+1; &#125; sort(idx,idx+_size); _size=unique(idx,idx+_size)-idx; build(1,1,_size); for(int i=1;i&lt;=m;i++) &#123; int l=lower_bound(idx,idx+_size,paint[i].l)-idx+1; int r=lower_bound(idx,idx+_size,paint[i].r)-idx+1; update(1,l,r,i); &#125; int cnt=0; for(int i=1;i&lt;=_size;i++) &#123; int tmp=query(1,i,i); if(tmp&gt;0) idx[cnt++]=tmp; &#125; sort(idx,idx+cnt); cout&lt;&lt;unique(idx,idx+cnt)-idx&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-3468 A Simple Problem with Integers]]></title>
    <url>%2F2019%2F04%2F13%2FPOJ-3468-A-Simple-Problem-with-Integers%2F</url>
    <content type="text"><![CDATA[You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.Each of the next Q lines represents an operation.“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.“Q a b” means querying the sum of Aa, Aa+1, … , Ab.OutputYou need to answer all Q commands in order. One answer in a line.Sample Input10 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4Sample Output455915HintThe sums may exceed the range of 32-bit integers.这道题是区间修改的板子题了。区间修改和点修改最大的区别就是使用了延迟标记，即子区间不立即更新增加了多少，而是记录下增加了多少值还未更新，在需要用到的时候再进行更新。那么什么时候需要更新呢，就是需要使用未更新的节点的值的时候（更新、查询时）。代码主要参考了https://blog.csdn.net/acceptedxukai/article/details/6933446 ，和之前传五个参不同，把每个点的左右边界都封装进了结构体，这样比较好看懂。AC代码：`cpp#include#includeusing namespace std;const int maxn=1e5+10;#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1long long sum[4maxn],add[4maxn];struct node{int l,r;int mid(){return (l+r)&gt;&gt;1;}}tree[4*maxn];void pushup(int rt){sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];}void pushdown(int rt,int m){if(add[rt]){add[rt&lt;&lt;1]+=add[rt];add[rt&lt;&lt;1|1]+=add[rt];sum[rt&lt;&lt;1]+=add[rt](m-(m&gt;&gt;1));sum[rt&lt;&lt;1|1]+=add[rt](m&gt;&gt;1);add[rt]=0;}}void build(int l,int r,int rt){tree[rt].l=l;tree[rt].r=r;add[rt]=0;if(l==r){scanf(“%lld”,&amp;sum[rt]);return ;}int m=tree[rt].mid();build(lson);build(rson);pushup(rt);}void update(int c,int l,int r,int rt) //表示对区间[l,r]内的每个数均加c，rt是根节点{if(tree[rt].l==l&amp;&amp;tree[rt].r==r){add[rt]+=c;sum[rt]+=(long long )c*(r-l+1);return ;}if(tree[rt].l==tree[rt].r)return ;pushdown(rt,tree[rt].r-tree[rt].l+1);int m=tree[rt].mid();if(r&lt;=m)update(c,l,r,rt&lt;&lt;1);else if(l&gt;m)update(c,l,r,rt&lt;&lt;1|1);else{update(c,l,m,rt&lt;&lt;1);update(c,m+1,r,rt&lt;&lt;1|1);}pushup(rt);}long long query(int l,int r,int rt){if(l==tree[rt].l&amp;&amp;r==tree[rt].r)return sum[rt];pushdown(rt,tree[rt].r-tree[rt].l+1);int m=tree[rt].mid();long long ans=0;if(r&lt;=m)ans+=query(l,r,rt&lt;&lt;1);else if(l&gt;m)ans+=query(l,r,rt&lt;&lt;1|1);else{ans+=query(l,m,rt&lt;&lt;1);ans+=query(m+1,r,rt&lt;&lt;1|1);}return ans;}int main(){int n,m;while(cin&gt;&gt;n&gt;&gt;m){build(1,n,1);while(m–){string s;cin&gt;&gt;s;int a,b,c;if(s[0]==’Q’){scanf(“%d %d”,&amp;a,&amp;b);cout&lt;&lt;query(a,b,1)&lt;&lt;endl;}else{scanf(“%d %d %d”,&amp;a,&amp;b,&amp;c);}return 0;}]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1754 I Hate It]]></title>
    <url>%2F2019%2F04%2F11%2FHDU-1754-I-Hate-It%2F</url>
    <content type="text"><![CDATA[很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。Input本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。Output对于每一次询问操作，在一行里面输出最高成绩。Sample Input5 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5Sample Output5659HintHuge input,the C function scanf() will work better than cin依然是超级板子的线段树，这次是求最大值了。注意点在上一题说的差不多了。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;int a[4*maxn];const int INF=0x3f3f3f3f;void pushup(int i)&#123; a[i]=max(a[i*2],a[i*2+1]);&#125;void build(int i,int l,int r)&#123; if(l==r) &#123; scanf("%d",&amp;a[i]); return; &#125; int m=(l+r)/2; build(i*2,l,m); build(i*2+1,m+1,r); pushup(i);&#125;int query(int ql,int qr,int i,int l,int r)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return a[i]; int m=(l+r)/2; int maxx=-INF; if(ql&lt;=m) maxx=max(maxx,query(ql,qr,i*2,l,m)); if(qr&gt;m) maxx=max(maxx,query(ql,qr,i*2+1,m+1,r)); return maxx;&#125;void update(int id,int val,int i,int l,int r)&#123; if(l==r) &#123; a[i]=val; return; &#125; int m=(l+r)/2; if(id&lt;=m) update(id,val,i*2,l,m); else update(id,val,i*2+1,m+1,r); pushup(i);&#125;int main()&#123; int n,m; string s; int x,y; while(cin&gt;&gt;n&gt;&gt;m) &#123; build(1,1,n); while(m--) &#123; cin&gt;&gt;s; scanf("%d%d",&amp;x,&amp;y); if(s[0]=='Q') cout&lt;&lt;query(x,y,1,1,n)&lt;&lt;endl; else update(x,y,1,1,n); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1166]]></title>
    <url>%2F2019%2F04%2F11%2FHDU-1166%2F</url>
    <content type="text"><![CDATA[C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.Input第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。Sample Input1101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10EndSample OutputCase 1:63359这道题基本就是线段树的板子题了，虽然蓝书讲的是最小值，但是换成和也不难理解。要注意的是和mid判断的时候是大于/小于还是大于等于/小于等于，边界很容易出错。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e4+10;int sum[4*maxn];void pushup(int i)&#123; sum[i]=sum[i*2]+sum[i*2+1];&#125;void build(int i,int l,int r)&#123; if(l==r) &#123; scanf("%d",&amp;sum[i]); return; &#125; int m=(l+r)/2; build(i*2,l,m); build(i*2+1,m+1,r); pushup(i);&#125;int query(int ql,int qr,int i,int l,int r)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return sum[i]; int m=(l+r)/2; int ans=0; if(ql&lt;=m) ans+=query(ql,qr,i*2,l,m); if(qr&gt;m) ans+=query(ql,qr,i*2+1,m+1,r); return ans;&#125;void update(int id,int val,int i,int l,int r)&#123; if(l==r) &#123; sum[i]+=val; return; &#125; int m=(l+r)/2; if(id&lt;=m) update(id,val,i*2,l,m); else update(id,val,i*2+1,m+1,r); pushup(i);&#125;int main()&#123; int T,n,kase=0; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n; build(1,1,n); string s; int x,y; printf("Case %d:\n",++kase); while(cin&gt;&gt;s) &#123; if(s[0]=='E') break; scanf("%d%d",&amp;x,&amp;y); if(s[0]=='A') update(x,y,1,1,n); if(s[0]=='S') update(x,-y,1,1,n); if(s[0]=='Q') printf("%d\n",query(x,y,1,1,n)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first of all]]></title>
    <url>%2F2019%2F04%2F09%2Ffirst-of-all%2F</url>
    <content type="text"><![CDATA[CSDN过于招摇，启动流浪博客计划，，，]]></content>
      <categories>
        <category>水</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
