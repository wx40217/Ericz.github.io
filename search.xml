<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[moss代码查重系统的使用及注意点]]></title>
    <url>%2F2019%2F05%2F10%2Fmoss%E4%BB%A3%E7%A0%81%E6%9F%A5%E9%87%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[这两天校赛搬砖，一个很重要的砖就是对代码进行查重。请教了学长以后，基本掌握了使用moss进行查重的方法。moss是斯坦福大学开发的一套查重系统（官网链接），它支持多种语言的查重，对付常用的反查重套路也有自己的手段。安装与使用标准的moss使用方式需要使用邮箱申请ID，但是邮件一写进去就石沉大海。这里我们使用一个GUI的客户端mistletoe,这也是moss官网推荐的方法之一，下载安装即可。安装后的界面如图选择代码文件夹就行，因为是对AC代码查重，也不需要加入BASE FILE（如果喜欢的话可以把标程加上），注意如果代码是txt格式的话要再后缀里自己加上*.txt。然后选择对应的语言（cc就是c++），点击RUN QUERY，如果没有出现问题就会打开一个网页显示查重的结果。注意moss的代码文件编码必须是ANSI（中文即GBK），如果代码含有中文就会采用UTF8格式，建议查重前先进行统一的代码编码转换。]]></content>
      <categories>
        <category>水</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>搬砖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces - 313B Ilya and Queries]]></title>
    <url>%2F2019%2F05%2F10%2FCodeForces-313B-Ilya-and-Queries%2F</url>
    <content type="text"><![CDATA[Ilya the Lion wants to help all his friends with passing exams. They need to solve the following problem to pass the IT exam.You’ve got string s = s1s2… sn (n is the length of the string), consisting only of characters “.” and “#” and m queries. Each query is described by a pair of integers li, ri (1 ≤ li &lt; ri ≤ n). The answer to the query li, ri is the number of such integers i (li ≤ i &lt; ri), that si = si + 1.Ilya the Lion wants to help his friends but is there anyone to help him? Help Ilya, solve the problem.InputThe first line contains string s of length n (2 ≤ n ≤ 105). It is guaranteed that the given string only consists of characters “.” and “#”.The next line contains integer m (1 ≤ m ≤ 105) — the number of queries. Each of the next m lines contains the description of the corresponding query. The i-th line contains integers li, ri (1 ≤ li &lt; ri ≤ n).OutputPrint m integers — the answers to the queries in the order in which they are given in the input.Examples1234567891011121314151617181920212223242526Input......43 42 31 62 6Output1154Input#..###51 35 61 53 63 4Output11220这题本身是很水的题，但是扫描的思想很有趣，直接用数组记录到i位置前面有多少组重复的，到时候减一下就完事，很类似于前缀和。AC代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int a[maxn];int main()&#123; string s; memset(a,0,sizeof(a)); cin&gt;&gt;s; for(int i=1;i&lt;s.size();i++) if(s[i]==s[i-1]) a[i]=a[i-1]+1; else a[i]=a[i-1]; int t; cin&gt;&gt;t; while(t--) &#123; int l,r; scanf("%d%d",&amp;l,&amp;r); cout&lt;&lt;a[r-1]-a[l-1]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>水</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces - 520B Two Buttons]]></title>
    <url>%2F2019%2F05%2F10%2FCodeForces-520B-Two-Buttons%2F</url>
    <content type="text"><![CDATA[Vasya has found a strange device. On the front panel of a device there are: a red button, a blue button and a display showing some positive integer. After clicking the red button, device multiplies the displayed number by two. After clicking the blue button, device subtracts one from the number on the display. If at some point the number stops being positive, the device breaks down. The display can show arbitrarily large numbers. Initially, the display shows number n.Bob wants to get number m on the display. What minimum number of clicks he has to make in order to achieve this result?InputThe first and the only line of the input contains two distinct integers n and m (1 ≤ n, m ≤ 104), separated by a space .OutputPrint a single number — the minimum number of times one needs to push the button required to get the number m out of number n.ExamplesInput4 6Output2Input10 1Output9NoteIn the first example you need to push the blue button once, and then push the red button once.In the second example, doubling the number is unnecessary, so we need to push the blue button nine times.这题好像以前做过。。。给你n和m，只能把n减一或乘二，问把n变到m需要多少步。网上很多题解都是BFS，看的我都吓坏了，现在CF的B都已经BFS了嘛。但实际上我局得类似贪心或者思维的做法更好。首先，对n操作和对m逆向操作是等价的，而当$n&gt;m$时n只能靠减自己来变成n，而乘二一定是比减一划算的，所以就是尽量乘二，不能乘二就减一。AC代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; int ans=0; while(n&lt;m) &#123; if(m&amp;1) &#123; m++; ans++; &#125; m&gt;&gt;=1; ans++; &#125; ans+=n-m; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;最近状态很差，只能刷刷水题找找手感和自信了……但是做水题都会卡壳，怎么办呢……]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>水</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA - 11468 Substring]]></title>
    <url>%2F2019%2F05%2F02%2FUVA-11468-Substring%2F</url>
    <content type="text"><![CDATA[Given a set of pattern strings, and a text, you have to find, if any of the pattern is a substring of thetext. If any of the pattern string can be found in text, then print ‘yes’, otherwise ‘no’ (without quotes).But, unfortunately, thats not what is asked here.The problem described above, requires a input file generator. The generator generates a text oflength L, by choosing L characters randomly. Probability of choosing each character is given as priori,and independent of choosing others.Now, given a set of patterns, calculate the probability of a valid program generating “no”.InputFirst line contains an integer T, the number of test cases. Each case starts with an integer K, thenumber of pattern strings. Next K lines each contain a pattern string, followed by an integer N,number of valid characters. Next N lines each contain a character and the probability of selecting thatcharacter, pi. Next an integer L, the length of the string generated. The generated text can consist ofonly the valid characters, given above.There will be a blank line after each test case.OutputFor each test case, output the number of test case, and the probability of getting a “no”.Constraints:• T ≤ 50• K ≤ 20• Length of each pattern string is between 1 and 20• Each pattern string consists of only alphanumeric characters (a to z, A to Z, 0 to 9)• Valid characters are all alphanumeric characters•∑pi = 1• L ≤ 100Sample Input21a2a 0.5b 0.522abab2a 0.2b 0.82Sample OutputCase #1: 0.250000Case #2: 0.840000这道题和POJ2778 这道题都有很大的相似之处，都是求出不含模板串的指定长度的文本串。区别有两个：文本串只含有指定字符，指定字符有概率出现，所以这是一道概率DP题……AC自动机真是什么都能加做的时候好像有很多想说，实际写的时候好像也没有什么好写的……判断是否含有模式串在poj2778讲过了，概率dp就是挺标准的正推概率，虽然之前做过概率dp的专题但是构造上是很不熟练……下次把专题的文章也搬过来吧。。。AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=410;const int maxm=64;struct node&#123; int ch[maxn][maxm]; int val[maxn]; int f[maxn]; int sz; double dp[maxn][110]; double p[maxm]; bool vis[maxn][maxn]; void init() &#123; sz=1; memset(ch[0],0,sizeof(ch[0])); val[0]=0; memset(p,0,sizeof(p)); memset(vis,false,sizeof(vis)); &#125; int idx(char c) &#123; if(c&gt;='a'&amp;&amp;c&lt;='z') return c-'a'; if(c&gt;='A'&amp;&amp;c&lt;='Z') return 26+c-'A'; if(c&gt;='0'&amp;&amp;c&lt;='9') return 52+c-'0'; &#125; void insert(char *s) &#123; int u=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); if (!ch[u][c]) &#123; memset(ch[sz],0,sizeof ch[sz]); val[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; val[u]=1; &#125; void build() &#123; queue&lt;int&gt;q; f[0]=0; for(int c=0;c&lt;maxm;c++) &#123; int u=ch[0][c]; if(u) &#123; f[u]=0; q.push(u); &#125; &#125; while(!q.empty()) &#123; int r=q.front();q.pop(); for(int c=0;c&lt;maxm;c++) &#123; int u=ch[r][c]; if(!u) &#123; ch[r][c]=ch[f[r]][c]; continue; &#125; q.push(u); int v=f[r]; f[u]=ch[v][c]; val[u]|=val[f[u]]; &#125; &#125; &#125; double solve(int u,int L) &#123; if(vis[u][L]) return dp[u][L]; if(!L) return dp[u][L]=1; vis[u][L]=true; dp[u][L]=0; for(int c=0;c&lt;maxm;c++) &#123; if(val[ch[u][c]]) continue; dp[u][L]+=p[c]*solve(ch[u][c],L-1); &#125; return dp[u][L]; &#125;&#125;ac;char s[30];int main()&#123; int T,kase=0; cin&gt;&gt;T; while(T--) &#123; ac.init(); int k; cin&gt;&gt;k; while(k--) &#123; scanf("%s",s); ac.insert(s); &#125; ac.build(); int n; cin&gt;&gt;n; while(n--) &#123; scanf("%s",s); scanf("%lf",&amp;ac.p[ac.idx(s[0])]); &#125; int L; cin&gt;&gt;L; printf("Case #%d: %.6lf\n",++kase,ac.solve(0,L)); &#125;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>DP. AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 2243 考研路茫茫――单词情结]]></title>
    <url>%2F2019%2F04%2F29%2FHDU-2243-%E8%80%83%E7%A0%94%E8%B7%AF%E8%8C%AB%E8%8C%AB%E2%80%95%E2%80%95%E5%8D%95%E8%AF%8D%E6%83%85%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背单词，始终是复习英语的重要环节。在荒废了3年大学生涯后，Lele也终于要开始背单词了。一天，Lele在某本单词书上看到了一个根据词根来背单词的方法。比如”ab”,放在单词前一般表示”相反，变坏，离去”等。于是Lele想，如果背了N个词根，那这些词根到底会不会在单词里出现呢。更确切的描述是：长度不超过L，只由小写字母组成的，至少包含一个词根的单词，一共可能有多少个呢？这里就不考虑单词是否有实际意义。比如一共有2个词根 aa 和 ab ，则可能存在104个长度不超过3的单词，分别为(2个) aa,ab,(26个)aaa,aab,aac…aaz,(26个)aba,abb,abc…abz,(25个)baa,caa,daa…zaa,(25个)bab,cab,dab…zab。这个只是很小的情况。而对于其他复杂点的情况，Lele实在是数不出来了，现在就请你帮帮他。Input本题目包含多组数据，请处理到文件结束。每组数据占两行。第一行有两个正整数N和L。(0&lt;N&lt;6,0&lt;L&lt;2^31)第二行有N个词根，每个词根仅由小写字母组成，长度不超过5。两个词根中间用一个空格分隔开。Output对于每组数据，请在一行里输出一共可能的单词数目。由于结果可能非常巨大，你只需要输出单词总数模2^64的值。Sample Input2 3aa ab1 2aSample Output10452这道题做的我要哭出来了……搞了好久好不容易把思路捋清楚了，自己写的代码却不停wa，最后耻辱借鉴了kuangbin的代码……这道题以后一定要搞清楚。首先我们要确定一个大问题：怎么求出可能的单词数目，也就是题目的要求。在上一道题里我们已经求过不含模板的n长度的串，放到这题，我们只要求出不含模板的长度小于n的串的和，然后用总和减去它就是含模板的串的长度就是最后的答案了。好像问题解决了？这才刚刚开始呢！这题的串长度可以达到2^31，如果老老实实算，不管是总和($26^1+26^2+…+26^n$)还是不包含的字串和（$M^1+M^2+…+M^n$ ,M为去除包含行列后的邻接矩阵）都会超时，所以两边都要优化。但是因为要求和。所以在POJ 2778 得到的L*L的矩阵中，需要增加一维，第L+1列全部为1这是kuangbin原话，不难使用也不难验证正确性，但是为什么呢？根据学长的讲解和我自己的理解，大概是这样：多了一列L+1，相当于放了一个虚拟节点，它的编号是L+1.这个节点可以存在字典树任何位置，因此它会“吞步”，意思说你走到它需要花n步(n为矩阵的幂)，但实际储存的是步数小于n的走法数量，因为这个节点不存在，走到它的实际是步数小于n的走法。当然自己是不能走到自己的，所以求出来的要减一。受到队友的启发，我想到，如果把整个矩阵M看成一个整体的话，加一位即$$\left{\begin{matrix}M &amp; 1 \0 &amp; 1 \\end{matrix}\right}$$乘自己即得到$$\left{\begin{matrix}M^2 &amp; M+1 \0 &amp; 1 \\end{matrix}\right}$$再乘就是$$\left{\begin{matrix}M^3 &amp; M^2+M+1 \0 &amp; 1 \\end{matrix}\right}$$这实际就是矩阵快速幂的递推用法！最后结果减1也是因为递推到最后结果是多了1的，刚刚好，就很妙。然后就是总序列的求法了，这个就是很干脆利落的真·矩阵快速幂了，定义f[n]=1 + 26^1 + 26^2 +…26^nf[n]=26*f[n-1]+1{f[n] 1} = {f[n-1] 1}[26 0;1 1]就能利用矩阵快速幂求出最后的解惹。最后还有一个问题，答案要对$2^{64}$取模,只要把数据开成unsigned long long就能自然地解决这个问题。然而讲了那么多还是不知道之前的代码错在哪了……如果有好心人知道的话麻烦告诉我一下……AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347/*#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;struct Matrix&#123; ull mat[40][40]; int n; Matrix ()&#123;&#125; Matrix (int _n) &#123; n=_n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) mat[i][j]=0; &#125; Matrix operator *(const Matrix &amp;b)const &#123; Matrix ret=Matrix(n); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) ret.mat[i][j]+=mat[i][k]*b.mat[k][j]; return ret; &#125;&#125;;ull pow_m(ull a,int n)&#123; ull ret=1; ull tmp=a; while(n) &#123; if(n&amp;1) ret*=tmp; tmp*=tmp; n&gt;&gt;=1; &#125; return ret;&#125;Matrix pow(Matrix a,int n)&#123; Matrix ret=Matrix(a.n); for(int i=0;i&lt;a.n;i++) ret.mat[i][i]=1; Matrix tmp=a; while(n) &#123; if(n&amp;1) ret=ret*tmp; tmp=tmp*tmp; n&gt;&gt;=1; &#125; return ret;&#125;const int maxn=40;const int maxm=26;const int N=120;struct node&#123; int ch[maxn][maxm],val[maxn],f[maxn],last[maxn],sz; void clear() &#123; sz=1;memset(ch[0],0,sizeof(ch[0])); &#125; int idx(char c) &#123; return c-'a'; &#125; void insert(char *s,int v) &#123; int u=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); if(!ch[u][c]) &#123; memset(ch[sz],0,sizeof(ch[sz])); val[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; val[u]=1; &#125; void build() &#123; queue&lt;int&gt;q; f[0]=0; for(int c=0;c&lt;maxm;c++) &#123; int u=ch[0][c]; if(u) &#123; f[u]=last[u]=0; q.push(u); &#125; &#125; while(!q.empty()) &#123; int r=q.front();q.pop(); for(int c=0;c&lt;maxm;c++) &#123; int u=ch[r][c]; if(!u) &#123; ch[r][c]=ch[f[r]][c]; val[r]=val[r]||val[f[r]]; continue; &#125; q.push(u); f[u]=ch[f[u]][c]; last[u]=val[f[u]]?f[u]:last[f[u]]; &#125; &#125; &#125;&#125;ac;//ull a[N][N];int n;Matrix init()&#123; n=ac.sz; Matrix ret=Matrix(n+1); int u; //memset(a,0,sizeof(a)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;maxm;j++) &#123; u=ac.ch[i][j]; if(!ac.val[u]) ret.mat[i][u]++; &#125; for(int i=0;i&lt;n+1;i++) ret.mat[i][n]=1; return ret;&#125;int main()&#123; char s[10]; int m,L; //ull b; while(cin&gt;&gt;m&gt;&gt;L) &#123; ac.clear(); for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s); ac.insert(s,i); &#125; ac.build(); Matrix a=init(); a=pow(a,L); ull res=0; for(int i=0;i&lt;a.n;i++) res+=a.mat[0][i]; res--; a=Matrix(2); a.mat[0][0]=26; a.mat[1][0]=a.mat[1][1]=1; a=pow(a,L); ull ans=a.mat[1][0]+a.mat[0][0]; ans--; ans-=res; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;*/#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;struct Matrix&#123; ull mat[40][40]; int n; Matrix ()&#123;&#125; Matrix (int _n) &#123; n=_n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) mat[i][j]=0; &#125; Matrix operator *(const Matrix &amp;b)const &#123; Matrix ret=Matrix(n); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) ret.mat[i][j]+=mat[i][k]*b.mat[k][j]; return ret; &#125;&#125;;ull pow_m(ull a,int n)&#123; ull ret=1; ull tmp=a; while(n) &#123; if(n&amp;1) ret*=tmp; tmp*=tmp; n&gt;&gt;=1; &#125; return ret;&#125;Matrix pow(Matrix a,int n)&#123; Matrix ret=Matrix(a.n); for(int i=0;i&lt;a.n;i++) ret.mat[i][i]=1; Matrix tmp=a; while(n) &#123; if(n&amp;1) ret=ret*tmp; tmp=tmp*tmp; n&gt;&gt;=1; &#125; return ret;&#125;struct node&#123; int ch[40][26],f[40]; bool last[40]; int sz,root; int newnode() &#123; for(int i=0;i&lt;26;i++) ch[sz][i]=-1; last[sz++]=false; return sz-1; &#125; void init() &#123; sz=0; root=newnode(); &#125; void insert(char *s) &#123; int now=root; for(int i=0;s[i];i++) &#123; if(ch[now][s[i]-'a']==-1) ch[now][s[i]-'a']=newnode(); now=ch[now][s[i]-'a']; &#125; last[now]=true; &#125; void build() &#123; queue&lt;int&gt;q; f[root]=root; for(int i=0;i&lt;26;i++) if(ch[root][i]==-1) ch[root][i]=root; else &#123; f[ch[root][i]]=root; q.push(ch[root][i]); &#125; while(!q.empty()) &#123; int now=q.front(); q.pop(); if(last[f[now]]) last[now]=true; for(int i=0;i&lt;26;i++) if(ch[now][i]==-1) ch[now][i]=ch[f[now]][i]; else &#123; f[ch[now][i]]=ch[f[now]][i]; q.push(ch[now][i]); &#125; &#125; &#125; Matrix getM() &#123; Matrix ret=Matrix(sz+1); for(int i=0;i&lt;sz;i++) for(int j=0;j&lt;26;j++) if(last[ch[i][j]]==false) ret.mat[i][ch[i][j]]++; for(int i=0;i&lt;sz+1;i++) ret.mat[i][sz]=1; return ret; &#125;&#125;ac;int main()&#123; char s[10]; int m,L; //ull b; while(cin&gt;&gt;m&gt;&gt;L) &#123; ac.init(); for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s); ac.insert(s); &#125; ac.build(); Matrix a=ac.getM(); a=pow(a,L); ull res=0; for(int i=0;i&lt;a.n;i++) res+=a.mat[0][i]; res--; a=Matrix(2); a.mat[0][0]=26; a.mat[1][0]=a.mat[1][1]=1; a=pow(a,L); ull ans=a.mat[1][0]+a.mat[0][0]; ans--; ans-=res; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>标记</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive - 4670 Dominating Patterns]]></title>
    <url>%2F2019%2F04%2F27%2F%C2%96%C2%96%C2%96UVALive-4670-Dominating-Patterns%2F</url>
    <content type="text"><![CDATA[The archaeologists are going to decipher a very mysterious “language”. Now, they know many languagepatterns; each pattern can be treated as a string on English letters (only lower case). As a sub string,these patterns may appear more than one times in a large text string (also only lower case Englishletters).What matters most is that which patterns are the dominating patterns. Dominating pattern is thepattern whose appearing times is not less than other patterns.It is your job to find the dominating pattern(s) and their appearing times.InputThe entire input contains multi cases. The first line of each case is an integer, which is the number ofpatterns N, 1 ≤ N ≤ 150. Each of the following N lines contains one pattern, whose length is in range[1, 70]. The rest of the case is one line contains a large string as the text to lookup, whose length is upto 106.At the end of the input file, number ‘0’ indicates the end of input file.OutputFor each of the input cases, output the appearing times of the dominating pattern(s). If there are morethan one dominating pattern, output them in separate lines; and keep their input order to the output.Sample Input2abababababababac6betaalphahahadeltadedetatadedeltalphahahahototatalpha0Sample Output4aba2alphahaha这题是个AC自动机模板题了，和前面的病毒侵袭很像。唯一的不同就是用map映射的字符串，大概是为了不重复？有点意义不明。今天做个水的 明天有个思索了好久的不知道能不能搞出来AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;const int maxm=26;map&lt;string,int&gt;ms;int cnt[160];struct node&#123; int ch[maxn][maxm],sz; int last[maxn],f[maxn],val[maxn]; void clear() &#123; sz=1; memset(ch[0],0,sizeof(ch[0])); memset(cnt,0,sizeof(cnt)); ms.clear(); &#125; int idx(char c) &#123; return c-'a'; &#125; void insert(char *s,int v) &#123; int u=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); if(!ch[u][c]) &#123; memset(ch[sz],0,sizeof(ch[sz])); val[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; val[u]=v; ms[string(s)]=v; &#125; void build() &#123; queue&lt;int&gt;q; f[0]=0; for(int c=0;c&lt;maxm;c++) &#123; int u=ch[0][c]; if(u) &#123; f[u]=0; q.push(u); last[u]=0; &#125; &#125; while(!q.empty()) &#123; int r=q.front();q.pop(); for(int c=0;c&lt;maxm;c++) &#123; int u=ch[r][c]; if(!u) &#123; ch[r][c]=ch[f[r]][c]; continue; &#125; q.push(u); f[u]=ch[f[r]][c]; last[u]=val[f[u]]?f[u]:last[f[u]]; &#125; &#125; &#125; void find(char *s) &#123; int j=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); j=ch[j][c]; if(val[j]) print(j); else if(last[j]) print(last[j]); &#125; &#125; void print(int j) &#123; if(j) &#123; cnt[val[j]]++; print(last[j]); &#125; &#125;&#125;ac;char s[200][80],text[maxn];int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n) &#123; ac.clear(); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s[i]); ac.insert(s[i],i); &#125; ac.build(); scanf("%s",text); ac.find(text); int maxx=-1; for(int i=1;i&lt;=n;i++) maxx=max(maxx,cnt[i]); cout&lt;&lt;maxx&lt;&lt;endl; for(int i=1;i&lt;=n;i++) if(cnt[ms[string(s[i])]]==maxx) cout&lt;&lt;s[i]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ - 2778 DNA Sequence及对AC自动机的一些理解]]></title>
    <url>%2F2019%2F04%2F26%2FPOJ-2778-DNA-Sequence%E5%8F%8A%E5%AF%B9AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[It’s well known that DNA Sequence is a sequence only contains A, C, T and G, and it’s very useful to analyze a segment of DNA Sequence，For example, if a animal’s DNA sequence contains segment ATC then it may mean that the animal may have a genetic disease. Until now scientists have found several those segments, the problem is how many kinds of DNA sequences of a species don’t contain those segments.Suppose that DNA sequences of a species is a sequence that consist of A, C, T and G，and the length of sequences is a given integer n.InputFirst line contains two integer m (0 &lt;= m &lt;= 10), n (1 &lt;= n &lt;=2000000000). Here, m is the number of genetic disease segment, and n is the length of sequences.Next m lines each line contain a DNA genetic disease segment, and length of these segments is not larger than 10.OutputAn integer, the number of DNA sequences, mod 100000.Sample Input4 3ATACAGAASample Output36在谈这题之前，先从我的理解谈谈AC自动机。现在给了你若干个字符串：acaezdgbcdbedgbcdge。。。zd然后输入字符串，求出输入的字符串中出现上列给出字符串的个数。这个问题有很多要考虑的地方，先考虑一个：开数组存字符串太低效了，时间空间上都是。查起来慢，存起来还占内存。这时候就需要字典树出马了。字典树不仅储存省地方效率还很高。这时候再考虑一种情况：输入字符串为aezd显然，它只含有zd一个给出的字符串，但是我们却要老老实实遍历整个字典树才能找到它，能不能优化它呢？注意到aezdg和zd长得很像，我们可以使用kmp的思想：判断到a—&gt;e—&gt;z—&gt;d时，下一个节点是g，失配，我们用一个失配指针，让d失配时指向zd，这不就减少遍历了吗。一个大概的例子所以，一个字符串失配时指向的字符串有两个性质：1.指向的字符串比自己短2.两个字符串有相同的后缀，如abcd可以指向bcd,cd,d也就是说，指向的字符串一定包含于失配的字符串。通过层层比较，就可以提前把相同后缀的匹配完成，再把没有相同后缀的节点失配指向根节点，就像kmp一样，查询指针不用往回走。本题题解大概如下这题运用到了我们前面推导的性质：因为指向的字符串包含与失配字符串，所以指向的字符串含有病毒子串时，失配（这题中不是真失配，只是做一个指向）字符串一定也含有病毒子串。然后就是若干线性代数知识。这题虽说用到了矩阵快速幂，但是只是普通的一个运用，和普通快速幂无差。等真要用到矩阵快速幂优化递推式的时候再仔细学吧……AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;const int maxn=110;const int maxm=4;const int mod=100000;const int maxnn=200;struct node&#123; int ch[maxn][maxm],val[maxn],f[maxn],last[maxn],sz; void clear() &#123; sz=1; memset(ch[0],0,sizeof(ch[0])); &#125; int idx(char c) &#123; if(c=='A') return 0; if(c=='C') return 1; if(c=='T') return 2; return 3; &#125; void insert(char *s,int v) &#123; int u=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); if(!ch[u][c]) &#123; memset(ch[sz],0,sizeof(ch[sz])); val[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; val[u]=1; &#125; void build() &#123; queue&lt;int&gt;q; f[0]=0; for(int c=0;c&lt;maxm;c++) &#123; int u=ch[0][c]; if(u) &#123; f[u]=last[u]=0; q.push(u); &#125; &#125; while(!q.empty()) &#123; int r=q.front();q.pop(); for(int c=0;c&lt;maxm;c++) &#123; int u=ch[r][c]; if(!u) &#123; ch[r][c]=ch[f[r]][c]; val[r]=val[r]||val[f[r]]; continue; &#125; q.push(u); f[u]=ch[f[r]][c]; last[u]=val[f[u]]?f[u]:last[f[u]]; &#125; &#125; &#125;&#125;ac;ll a[maxnn][maxnn];int n;void mul(ll a[][maxnn],ll b[][maxnn],ll c[][maxnn])&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) &#123; c[i][j]=0; for(int k=0;k&lt;n;k++) c[i][j]=(c[i][j]+a[i][k]*b[k][j])%mod; &#125;&#125;void copy(ll d[][maxnn],ll s[][maxnn])&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) d[i][j]=s[i][j];&#125;void pow(ll a[][maxnn],ll b)&#123; ll t[maxnn][maxnn],ret[maxnn][maxnn]; for(int i=0;i&lt;n;i++) ret[i][i]=1; while(b) &#123; if(b&amp;1) &#123; mul(ret,a,t); copy(ret,t); &#125; mul(a,a,t); copy(a,t); b&gt;&gt;=1; &#125; copy(a,ret);&#125;void init()&#123; n=ac.sz; int u; memset(a,0,sizeof(a)); for(int i=0;i&lt;n;i++) if(!ac.val[i]) for(int j=0;j&lt;4;j++) &#123; u=ac.ch[i][j]; if(!ac.val[u]) a[i][u]++; &#125;&#125;int main()&#123; char s[12]; int m; ll b; while(cin&gt;&gt;m&gt;&gt;b) &#123; ac.clear(); for(int i=1;i&lt;=m;i++) &#123; scanf("%s",s); ac.insert(s,i); &#125; ac.build(); init(); pow(a,b); ll sum=0; for(int i=0;i&lt;n;i++) sum=(sum+a[0][i])%mod; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 3065 病毒侵袭持续中]]></title>
    <url>%2F2019%2F04%2F22%2FHDU-3065-%E7%97%85%E6%AF%92%E4%BE%B5%E8%A2%AD%E6%8C%81%E7%BB%AD%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[小t非常感谢大家帮忙解决了他的上一个问题。然而病毒侵袭持续中。在小t的不懈努力下，他发现了网路中的“万恶之源”。这是一个庞大的病毒网站，他有着好多好多的病毒，但是这个网站包含的病毒很奇怪，这些病毒的特征码很短，而且只包含“英文大写字符”。当然小t好想好想为民除害，但是小t从来不打没有准备的战争。知己知彼，百战不殆，小t首先要做的是知道这个病毒网站特征：包含多少不同的病毒，每种病毒出现了多少次。大家能再帮帮他吗？Input第一行，一个整数N（1&lt;=N&lt;=1000），表示病毒特征码的个数。接下来N行，每行表示一个病毒特征码，特征码字符串长度在1—50之间，并且只包含“英文大写字符”。任意两个病毒特征码，不会完全相同。在这之后一行，表示“万恶之源”网站源码，源码字符串长度在2000000之内。字符串中字符都是ASCII码可见字符（不包括回车）。Output按以下格式每行一个，输出每个病毒出现次数。未出现的病毒不需要输出。病毒特征码: 出现次数冒号后有一个空格，按病毒特征码的输入顺序进行输出。Sample Input3AABBCCooxxCC%dAAAoen….ENDSample OutputAA: 2CC: 1HintHit：题目描述中没有被提及的所有情况都应该进行考虑。比如两个病毒特征码可能有相互包含或者有重叠的特征码段。计数策略也可一定程度上从Sample中推测。这道题表面上就是统计每个特征码的出现次数，但是实际上险象环生：网站源码可能长达两百万，还有很多的无效字符！这就需要预处理了，首先得用gets()进行输入，其次要把无关的字符全都去掉只留下大写字符，代码中用的方法是多开一个字符数组，如果是连续大写字母就存起来，如果断了就把存起来的查一发。下午做的时候抽了，想不到怎么保证cnt和特征码同步，后来想想val里储存的就是特征码的编号嘛，把val中的编号对应cnt++就完事了。据说c++11没有gets()了……那以后该怎么办呢……AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=6e4+10;const int maxm=30;char s[1010][60],t[2000010],a[2000010];int n,cnt[1010];struct node&#123; int ch[maxn][maxm],sz; int val[maxn],last[maxn],f[maxn]; void clear()&#123; sz=1;memset(ch[0],0,sizeof(ch));&#125; int idx(char c) &#123;return c-'A';&#125; void insert(char *s,int v) &#123; int u=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); if(!ch[u][c]) &#123; memset(ch[sz],0,sizeof(ch[sz])); val[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; val[u]=v; &#125; void get_fail() &#123; queue&lt;int&gt;q; f[0]=0; for(int c=0;c&lt;maxm;c++) &#123; int u=ch[0][c]; if(u) &#123; f[u]=0; q.push(u); last[u]=0; &#125; &#125; while(!q.empty()) &#123; int r=q.front();q.pop(); for(int c=0;c&lt;maxm;c++) &#123; int u=ch[r][c]; if(!u) &#123; ch[r][c]=ch[f[r]][c]; continue; &#125; q.push(u); f[u]=ch[f[r]][c]; last[u]=val[f[u]]?f[u]:last[f[u]]; &#125; &#125; &#125; void find(char *s) &#123; int j=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); j=ch[j][c]; if(val[j]) print(j); else if(last[j]) print(last[j]); &#125; &#125; void print(int j) &#123; if(j) &#123; cnt[val[j]]++; print(last[j]); &#125; &#125;&#125;ac;int main()&#123; while(cin&gt;&gt;n) &#123; ac.clear(); memset(cnt,0,sizeof(cnt)); getchar(); for(int i=1;i&lt;=n;i++) &#123; gets(s[i]); ac.insert(s[i],i); &#125; ac.get_fail(); gets(t); int j=0; bool flag=false; for(int i=0;t[i];i++) &#123; if(t[i]&lt;='Z'&amp;&amp;t[i]&gt;='A') &#123; flag=true; a[j++]=t[i]; &#125; else if (flag) &#123; a[j]=0;j=0; flag=false; ac.find(a); &#125; &#125; if(flag) &#123; a[j]=0;j=0; flag=false;ac.find(a); &#125; for(int i=1;i&lt;=n;i++) if(cnt[i]&amp;&amp;s[i][0]) printf("%s: %d\n", s[i], cnt[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 2896 病毒侵袭]]></title>
    <url>%2F2019%2F04%2F22%2FHDU-2896-%E7%97%85%E6%AF%92%E4%BE%B5%E8%A2%AD%2F</url>
    <content type="text"><![CDATA[当太阳的光辉逐渐被月亮遮蔽，世界失去了光明，大地迎来最黑暗的时刻。。。。在这样的时刻，人们却异常兴奋——我们能在有生之年看到500年一遇的世界奇观，那是多么幸福的事儿啊~~但网路上总有那么些网站，开始借着民众的好奇心，打着介绍日食的旗号，大肆传播病毒。小t不幸成为受害者之一。小t如此生气，他决定要把世界上所有带病毒的网站都找出来。当然，谁都知道这是不可能的。小t却执意要完成这不能的任务，他说：“子子孙孙无穷匮也！”（愚公后继有人了）。万事开头难，小t收集了好多病毒的特征码，又收集了一批诡异网站的源码，他想知道这些网站中哪些是有病毒的，又是带了怎样的病毒呢？顺便还想知道他到底收集了多少带病毒的网站。这时候他却不知道何从下手了。所以想请大家帮帮忙。小t又是个急性子哦，所以解决问题越快越好哦~~Input第一行，一个整数N（1&lt;=N&lt;=500），表示病毒特征码的个数。接下来N行，每行表示一个病毒特征码，特征码字符串长度在20—200之间。每个病毒都有一个编号，依此为1—N。不同编号的病毒特征码不会相同。在这之后一行，有一个整数M（1&lt;=M&lt;=1000），表示网站数。接下来M行，每行表示一个网站源码，源码字符串长度在7000—10000之间。每个网站都有一个编号，依此为1—M。以上字符串中字符都是ASCII码可见字符（不包括回车）。Output依次按如下格式输出按网站编号从小到大输出，带病毒的网站编号和包含病毒编号，每行一个含毒网站信息。web 网站编号: 病毒编号 病毒编号 …冒号后有一个空格，病毒编号按从小到大排列，两个病毒编号之间用一个空格隔开，如果一个网站包含病毒，病毒数不会超过3个。最后一行输出统计信息，如下格式total: 带病毒网站数冒号后有一个空格。Sample Input3aaabbbccc2aaabbbcccbbaaccSample Outputweb 1: 1 2 3total: 1依然是AC自动机的板子，和上一题的区别是上一题只要统计出现单词的个数，这次要统计全部出现的编号。用一个vector把全部出现的都推进去，再用unique去重就行了###AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=6e4+10;const int maxm=130;vector&lt;int&gt;ans;struct node&#123; int ch[maxn][maxm],sz; int val[maxn],last[maxn],f[maxn]; void clear()&#123; sz=1;memset(ch[0],0,sizeof(ch));&#125; int idx(char c) &#123;return c;&#125; void insert(char *s,int v) &#123; int u=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); if(!ch[u][c]) &#123; memset(ch[sz],0,sizeof(ch[sz])); val[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; val[u]=v; &#125; void get_fail() &#123; queue&lt;int&gt;q; f[0]=0; for(int c=0;c&lt;maxm;c++) &#123; int u=ch[0][c]; if(u) &#123; f[u]=0; q.push(u); last[u]=0; &#125; &#125; while(!q.empty()) &#123; int r=q.front();q.pop(); for(int c=0;c&lt;maxm;c++) &#123; int u=ch[r][c]; if(!u) &#123; ch[r][c]=ch[f[r]][c]; continue; &#125; q.push(u); f[u]=ch[f[r]][c]; last[u]=val[f[u]]?f[u]:last[f[u]]; &#125; &#125; &#125; void find(char *s) &#123; int j=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); j=ch[j][c]; if(val[j]) print(j); else if(last[j]) print(last[j]); &#125; &#125; void print(int j) &#123; if(j) &#123; ans.push_back(val[j]); print(last[j]); &#125; &#125;&#125;ac;char s[250],t[10010];int main()&#123; int n,m; while(cin&gt;&gt;n) &#123; ac.clear(); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s); ac.insert(s,i); &#125; ac.get_fail(); cin&gt;&gt;m; int tot=0; for(int i=1;i&lt;=m;i++) &#123; ans.clear(); scanf("%s",t); ac.find(t); if(ans.size()==0) continue; sort(ans.begin(),ans.end()); int k=unique(ans.begin(),ans.end())-ans.begin(); printf("web %d:",i); for(int j=0;j&lt;k;j++) printf(" %d",ans[j]); cout&lt;&lt;endl; tot++; &#125; printf("total: %d\n",tot); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 2222 Keywords Search]]></title>
    <url>%2F2019%2F04%2F21%2FHDU-2222-Keywords-Search%2F</url>
    <content type="text"><![CDATA[In the modern time, Search engine came into the life of everybody like Google, Baidu, etc.Wiskey also wants to bring this feature to his image retrieval system.Every image have a long description, when users type some keywords to find the image, the system will match the keywords with description of image and show the image which the most keywords be matched.To simplify the problem, giving you a description of image, and some keywords, you should tell me how many keywords will be match.InputFirst line will contain one integer means how many cases will follow by.Each case will contain two integers N means the number of keywords and N keywords follow. (N &lt;= 10000)Each keyword will only contains characters ‘a’-‘z’, and the length will be not longer than 50.The last line is the description, and the length will be not longer than 1000000.OutputPrint how many keywords are contained in the description.Sample Input15shehesayshrheryasherhsSample Output3AC自动机牛逼！这是我做的第一道AC自动机的题目了，心里还是有点小激动。因为AC自动机这个名词一直萦绕我的耳边，作为一个万能而高端的算法存在。如今我终于也能触及这算法的一个小角了。学习AC自动机的前提是字典树和kmp，更准确的说是kmp的失配算法。这两块一定要好好掌握，我就因为字典树掌握的不太好吃了亏。推荐几篇博文：这个PPT深入浅出，对失配指针的寻找讲解很生动上古神触的博客，讲解非常到位，可惜是指针写法最后的写法是用蓝书的板子改的，我个人感觉不错，数组和结构体保证了整体代码的可读性和简洁，count数组即val数组，在本题中用以维护以j为结尾的单词个数我说啥胡话呢，以j为结尾的单词当然是唯一的，维护的是该单词的出现次数。AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=240000+10;const int maxm=26;int cnt;struct AC_Automata&#123; int ch[maxn][maxm],sz; int last[maxn],f[maxn],count[maxn]; void clear() &#123; sz=1;memset(ch[0],0,sizeof(ch[0])); &#125; int idx(char c)&#123;return c-'a';&#125;; void insert(char *s,int v) &#123; int u=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); if(!ch[u][c]) &#123; memset(ch[sz],0,sizeof(ch[sz])); count[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; count[u]++; //val[u]=v; &#125; void build() &#123; queue&lt;int&gt;q; f[0]=0; for(int c=0;c&lt;maxm;c++) &#123; int u=ch[0][c]; if(u) &#123; f[u]=0; q.push(u);last[u]=0; &#125; &#125; while(!q.empty()) &#123; int r=q.front();q.pop(); for(int c=0;c&lt;maxm;c++) &#123; int u=ch[r][c]; if(!u) &#123; ch[r][c]=ch[f[r]][c]; continue; &#125; q.push(u); int v=f[r]; f[u]=ch[v][c]; last[u]=count[f[u]]?f[u]:last[f[u]]; &#125; &#125; &#125; void find(char *s) &#123; int j=0; for(int i=0;s[i];i++) &#123; int c=idx(s[i]); j=ch[j][c]; if(count[j]) print(j); else if(last[j]) print(last[j]); &#125; &#125; void print(int j) &#123; if(j) &#123; cnt+=count[j]; count[j]=0; print(last[j]); &#125; &#125;&#125;ac;char s[55],text[1000010];int main()&#123; int n,T; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n; ac.clear(); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s); ac.insert(s,i); &#125; ac.build(); cnt=0; scanf("%s",text); ac.find(text); printf("%d\n",cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive - 3026 Period]]></title>
    <url>%2F2019%2F04%2F21%2FUVALive-3026-Period%2F</url>
    <content type="text"><![CDATA[For each prefix of a given string S with N characters (each character has an ASCII code between 97 and126, inclusive), we want to know whether the prefix is a periodic string. That is, for each i (2 ≤ i ≤ N)we want to know the largest K &gt; 1 (if there is one) such that the prefix of S with length i can bewritten as AK, that is A concatenated K times, for some string A. Of course, we also want to knowthe period K.InputThe input file consists of several test cases. Each test case consists of two lines. The first one containsN (2 ≤ N ≤ 1000000) the size of the string S. The second line contains the string S. The input fileends with a line, having the number zero on it.OutputFor each test case, output ‘Test case #’ and the consecutive test case number on a single line; then, foreach prefix with length i that has a period K &gt; 1, output the prefix size i and the period K separatedby a single space; the prefix sizes must be in increasing order. Print a blank line after each test case.Sample Input3aaa12aabaabaabaab0Sample OutputTest case #12 23 3Test case #22 26 29 312 4这题说是kmp，其实是用到了一部分kmp的思想。kmp网上的介绍很多了不做赘述，这里用到的实际是next数组的思想。很容易想到，如果你和一个子串不能匹配，那么和他相同的子串你也不能匹配。next数组的作用就是告诉程序，我这前边有多少个字符是已经出现过了，你看着匹配吧。放到这个程序里，就是你已经知道next数组里重复的个数了，如果k(i-next[i])=i成立，那就是一个循环节uva居然不能用next命名 搞得我ce了一次AC代码：12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int f[maxn];string p;int main()&#123; int n,kase=0; while(cin&gt;&gt;n&amp;&amp;n) &#123; cin&gt;&gt;p; string t; f[0]=0; f[1]=0; for(int i=1;i&lt;n;i++) &#123; int j=f[i]; while(j&amp;&amp;p[i]!=p[j]) j=f[j]; f[i+1]=(p[i]==p[j]?j+1:0); &#125; printf("Test case #%d\n",++kase); for(int i=2;i&lt;=n;i++) if(f[i]&gt;0 &amp;&amp; i%(i-f[i])==0) cout&lt;&lt;i&lt;&lt;' '&lt;&lt;i/(i-f[i])&lt;&lt;endl; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive - 3942 Remember the Word]]></title>
    <url>%2F2019%2F04%2F19%2FUVALive-3942-Remember-the-Word%2F</url>
    <content type="text"><![CDATA[Neal is very curious about combinatorial problems, and now here comes a problem about words. Knowing that Ray has a photographic memory and this may not trouble him, Neal gives it to Jiejie.Since Jiejie can’t remember numbers clearly, he just uses sticks to help himself. Allowing for Jiejie’sonly 20071027 sticks, he can only record the remainders of the numbers divided by total amount ofsticks.The problem is as follows: a word needs to be divided into small pieces in such a way that eachpiece is from some given set of words. Given a word and the set of words, Jiejie should calculate thenumber of ways the given word can be divided, using the words in the set.InputThe input file contains multiple test cases. For each test case: the first line contains the given wordwhose length is no more than 300 000.The second line contains an integer S, 1 ≤ S ≤ 4000.Each of the following S lines contains one word from the set. Each word will be at most 100characters long. There will be no two identical words and all letters in the words will be lowercase.There is a blank line between consecutive test cases.You should proceed to the end of file.OutputFor each test case, output the number, as described above, from the task description modulo 20071027.Sample Inputabcd4abcdabSample OutputCase 1: 2很容易能反应出这是一道DP，设dp(i)表示原字符串的子串[i,len-1]的划分方案数，那么dp(i)=sum{dp(i+len(x)) | x是某个单词，同时x为[i,len-1]的前缀 }，边界是dp(len)=1。但是问题是怎么找出是前缀的x，这时候就要使用前缀树了。说是这么说 我做的还是迷迷糊糊的AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int mod=20071027;const int maxn=4e5+10;string p,s;int trie[maxn][26],tot;int deep[maxn];bool isword[maxn];int dp[maxn];int num,len;void init()&#123; len=p.size(); tot=0; memset(trie,0,sizeof(trie)); memset(isword,0,sizeof(isword)); memset(deep,0,sizeof(deep)); memset(dp,-1,sizeof(dp));&#125;int dfs(int i)&#123; if(i==len) return 1; if(dp[i]!=-1) return dp[i]; int node=0,ans=0; for(int j=i;j&lt;len;++j) &#123; int id=p[j]-'a'; node=trie[node][id]; if(isword[node]) ans=(ans+dfs(i+deep[node]))%mod; if(!node) break; &#125; return dp[i]=ans;&#125;void insert()&#123; int node=0; for(int i=0;s[i];i++) &#123; int id=s[i]-'a'; if(!trie[node][id]) &#123; trie[node][id]=++tot; deep[trie[node][id]]=deep[node]+1; &#125; node=trie[node][id]; &#125; isword[node]=true;&#125;int main()&#123; int kase=0; while(cin&gt;&gt;p) &#123; init(); cin&gt;&gt;num; while(num--) &#123; cin&gt;&gt;s; insert(); &#125; int ans=dfs(0); printf("Case %d: %d\n",++kase,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ - 3264 Balanced Lineup]]></title>
    <url>%2F2019%2F04%2F17%2FPOJ-3264-Balanced-Lineup%2F</url>
    <content type="text"><![CDATA[For the daily milking, Farmer John’s N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height.Farmer John has made a list of Q (1 ≤ Q ≤ 200,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.InputLine 1: Two space-separated integers, N and Q.Lines 2.. N+1: Line i+1 contains a single integer that is the height of cow iLines N+2.. N+ Q+1: Two integers A and B (1 ≤ A ≤ B ≤ N), representing the range of cows from A to B inclusive.OutputLines 1.. Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range.Sample Input6 31734251 54 62 2Sample Output630这道题和前面的题相比反倒难度下降了……就是维护最大值和最小值，没了，甚至没有更新只有查询。。。。。。AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn=7e4+10;struct Node&#123; int l,r; int minn,maxx;&#125;tree;Node node[4*maxn];int num[maxn],minn,maxx;void build(int o,int l,int r)&#123; node[o].l=l;node[o].r=r; if(node[o].l==node[o].r) &#123; node[o].maxx=node[o].minn=num[l]; return; &#125; int mid=(node[o].l+node[o].r)/2; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); node[o].maxx=max(node[o&lt;&lt;1].maxx,node[o&lt;&lt;1|1].maxx); node[o].minn=min(node[o&lt;&lt;1].minn,node[o&lt;&lt;1|1].minn);&#125;void query(int o,int l,int r)&#123; if(node[o].l==l&amp;&amp;node[o].r==r) &#123; maxx=max(node[o].maxx,maxx); minn=min(node[o].minn,minn); return; &#125; int mid=(node[o].l+node[o].r)/2; if(l&gt;mid) query(o&lt;&lt;1|1,l,r); else if(r&lt;=mid) query(o&lt;&lt;1,l,r); else &#123; query(o&lt;&lt;1,l,mid); query(o&lt;&lt;1|1,mid+1,r); &#125;&#125;int main()&#123; int n,m,a,b; memset(node,0,sizeof(node)); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;num[i]); build(1,1,n); while(m--) &#123; scanf("%d%d",&amp;a,&amp;b); maxx=0;minn=0x3f3f3f3f; query(1,a,b); cout&lt;&lt;maxx-minn&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ - 1610 Count the Colors]]></title>
    <url>%2F2019%2F04%2F17%2FZOJ-1610-Count-the-Colors%2F</url>
    <content type="text"><![CDATA[Painting some colored segments on a line, some previously painted segments may be covered by some the subsequent ones.Your task is counting the segments of different colors you can see at last.InputThe first line of each data set contains exactly one integer n, 1 &lt;= n &lt;= 8000, equal to the number of colored segments.Each of the following n lines consists of exactly 3 nonnegative integers separated by single spaces:x1 x2 cx1 and x2 indicate the left endpoint and right endpoint of the segment, c indicates the color of the segment.All the numbers are in the range [0, 8000], and they are all integers.Input may contain several data set, process to the end of file.OutputEach line of the output should contain a color index that can be seen from the top, following the count of the segments of this color, they should be printed according to the color index.If some color can’t be seen, you shouldn’t print it.Print a blank line after every dataset.Sample Input50 4 40 3 13 4 20 2 20 2 340 1 13 4 11 3 21 3 160 1 01 2 12 3 11 2 02 3 01 2 1Sample Output1 12 13 11 10 21 1这题本身是一个区间覆盖的题，但是存在边界的问题，所以在数据处理上要注意边界的位置。AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=8e3+10;struct Node&#123; int l,r; int color;&#125;node[4*maxn];int color[maxn];int temp;void build(int i,int l,int r)&#123; node[i].l=l; node[i].r=r; node[i].color=-1; if(l+1==r) return; int mid=(l+r)&gt;&gt;1; build(i&lt;&lt;1,l,mid); build(i&lt;&lt;1|1,mid,r);&#125;void insert(int i,int l,int r,int c)&#123; if(l==r) return; if(node[i].color==c) return; if(l&lt;=node[i].l&amp;&amp;r&gt;=node[i].r) &#123; node[i].color=c; return; &#125; if(node[i].color&gt;=0) &#123; node[i&lt;&lt;1].color=node[i].color; node[i&lt;&lt;1|1].color=node[i].color; node[i].color=-2; &#125; int mid=(node[i].l+node[i].r)&gt;&gt;1; if(r&lt;=mid) insert(i&lt;&lt;1,l,r,c); else if(l&gt;=mid) insert(i&lt;&lt;1|1,l,r,c); else &#123; insert(i&lt;&lt;1,l,mid,c); insert(i&lt;&lt;1|1,mid,r,c); &#125; node[i].color=-2;&#125;void count(int i)&#123; if(node[i].color==-1) &#123; temp=-1; return; &#125; if(node[i].color!=-2) &#123; if(node[i].color!=temp) &#123; color[node[i].color]++; temp=node[i].color; &#125; return; &#125; if(node[i].l+1!=node[i].r) &#123; count(i&lt;&lt;1); count((i&lt;&lt;1)|1); &#125;&#125;int main()&#123; int n,a,b,c; int maxx; while(cin&gt;&gt;n) &#123; build(1,0,8000); maxx=0; while(n--) &#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); insert(1,a,b,c); maxx=max(c,maxx); &#125; temp=-1; memset(color,0,sizeof(color)); count(1); for(int i=0;i&lt;=maxx;i++) if(color[i]) cout&lt;&lt;i&lt;&lt;' '&lt;&lt;color[i]&lt;&lt;endl; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1698 Just a Hook]]></title>
    <url>%2F2019%2F04%2F16%2FHDU-1698-Just-a-Hook%2F</url>
    <content type="text"><![CDATA[In the game of DotA, Pudge’s meat hook is actually the most horrible thing for most of the heroes. The hook is made up of several consecutive metallic sticks which are of the same length.Now Pudge wants to do some operations on the hook.Let us number the consecutive metallic sticks of the hook from 1 to N. For each operation, Pudge can change the consecutive metallic sticks, numbered from X to Y, into cupreous sticks, silver sticks or golden sticks.The total value of the hook is calculated as the sum of values of N metallic sticks. More precisely, the value for each kind of stick is calculated as follows:For each cupreous stick, the value is 1.For each silver stick, the value is 2.For each golden stick, the value is 3.Pudge wants to know the total value of the hook after performing the operations.You may consider the original hook is made up of cupreous sticks.InputThe input consists of several test cases. The first line of the input is the number of the cases. There are no more than 10 cases.For each case, the first line contains an integer N, 1&lt;=N&lt;=100,000, which is the number of the sticks of Pudge’s meat hook and the second line contains an integer Q, 0&lt;=Q&lt;=100,000, which is the number of the operations.Next Q lines, each line contains three integers X, Y, 1&lt;=X&lt;=Y&lt;=N, Z, 1&lt;=Z&lt;=3, which defines an operation: change the sticks numbered from X to Y into the metal kind Z, where Z=1 represents the cupreous kind, Z=2 represents the silver kind and Z=3 represents the golden kind.OutputFor each case, print a number in a line representing the total value of the hook after the operations. Use the format in the example.Sample Input11021 5 25 9 3Sample OutputCase 1: The total value of the hook is 24.这道题是线段树区间覆盖的板子题了（不带查询的板子题），蓝书上说的区间覆盖有点悬，但是实际上，只要有新的覆盖就把旧的延迟标记覆盖了就完事了。不过这也让我想到，如果有覆盖和更新并存的情况，也是直接处理就行吗……顺便吐槽 区间覆盖好像没一个确定的名字，搜半天搜不到，都是区间更新的AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int sum[4*maxn],ans[4*maxn];void pushup(int o)&#123; sum[o]=sum[o&lt;&lt;1]+sum[o&lt;&lt;1|1];&#125;void pushdown(int o,int l,int r)&#123; if(ans[o]) &#123; int m=l+(r-l)/2; ans[o&lt;&lt;1]=ans[o&lt;&lt;1|1]=ans[o]; sum[o&lt;&lt;1]=(m-l+1)*ans[o]; sum[o&lt;&lt;1|1]=(r-m)*ans[o]; ans[o]=0; &#125;&#125;void build(int l,int r,int o)&#123; int m=l+(r-l)/2; ans[o]=0; if(l==r) &#123; sum[o]=1; return; &#125; build(l,m,o&lt;&lt;1); build(m+1,r,o&lt;&lt;1|1); pushup(o);&#125;void update(int L,int R,int c,int l,int r,int o)&#123; int m=l+(r-l)/2; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; ans[o]=c; sum[o]=(r-l+1)*c; return; &#125; pushdown(o,l,r); if(L&lt;=m) update(L,R,c,l,m,o&lt;&lt;1); if(m&lt;R) update(L,R,c,m+1,r,o&lt;&lt;1|1); pushup(o);&#125;int main()&#123; int t; cin&gt;&gt;t; int kase=0; while(t--) &#123; int n,q; cin&gt;&gt;n&gt;&gt;q; build(1,n,1); while(q--) &#123; int l,r,c; scanf("%d%d%d",&amp;l,&amp;r,&amp;c); update(l,r,c,1,n,1); &#125; printf("Case %d: The total value of the hook is %d.\n",++kase,sum[1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ - 2528 Mayor's posters]]></title>
    <url>%2F2019%2F04%2F16%2FPOJ-2528-Mayor-s-posters%2F</url>
    <content type="text"><![CDATA[The citizens of Bytetown, AB, could not stand that the candidates in the mayoral election campaign have been placing their electoral posters at all places at their whim. The city council has finally decided to build an electoral wall for placing the posters and introduce the following rules:Every candidate can place exactly one poster on the wall.All posters are of the same height equal to the height of the wall; the width of a poster can be any integer number of bytes (byte is the unit of length in Bytetown).The wall is divided into segments and the width of each segment is one byte.Each poster must completely cover a contiguous number of wall segments.They have built a wall 10000000 bytes long (such that there is enough place for all candidates). When the electoral campaign was restarted, the candidates were placing their posters on the wall and their posters differed widely in width. Moreover, the candidates started placing their posters on wall segments already occupied by other posters. Everyone in Bytetown was curious whose posters will be visible (entirely or in part) on the last day before elections.Your task is to find the number of visible posters when all the posters are placed given the information about posters’ size, their place and order of placement on the electoral wall.InputThe first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 &lt;= n &lt;= 10000. The subsequent n lines describe the posters in the order in which they were placed. The i-th line among the n lines contains two integer numbers l i and ri which are the number of the wall segment occupied by the left end and the right end of the i-th poster, respectively. We know that for each 1 &lt;= i &lt;= n, 1 &lt;= l i &lt;= ri &lt;= 10000000. After the i-th poster is placed, it entirely covers all wall segments numbered l i, l i+1 ,… , ri.OutputFor each input data set print the number of visible posters after all the posters are placed.The picture below illustrates the case of the sample input.Sample Input151 42 68 103 47 10Sample Output4这道题……emmmmmm中间隔了个数学建模，实际我完全不知道自己做的是啥了，只知道这是线段树加数据离散化，然而数据离散化我也不会，问题很大。AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=4e4+5;int m,a[maxn];int idx[maxn];struct Paint&#123; int l,r;&#125;paint[maxn];struct Node&#123; int l,r; int val,lazy; void update(LL x) &#123; val=(r-l+1)*x; lazy=x; &#125;&#125;node[4*maxn];void pushdown(int root)&#123; if(node[root].lazy) &#123; node[root*2].update(node[root].lazy); node[root*2+1].update(node[root].lazy); node[root].lazy=0; &#125;&#125;void pushup(int root)&#123; node[root].val=max(node[root*2].val,node[root*2+1].val);&#125;void build(int root,int l,int r)&#123; node[root].l=l; node[root].r=r; node[root].val=0; node[root].lazy=0; if(l==r) node[root].val=a[l]; else &#123; int mid=l+(r-l)/2; build(root*2,l,mid); build(root*2+1,mid+1,r); pushup(root); &#125;&#125;void update(int root,int st,int ed,int val)&#123; if(st&gt;node[root].r||ed&lt;node[root].l) return ; if(st&lt;=node[root].l&amp;&amp;node[root].r&lt;=ed) node[root].update(val); else &#123; pushdown(root); update(root*2,st,ed,val); update(root*2+1,st,ed,val); pushup(root); &#125;&#125;int query(int root,int st,int ed)&#123; if(ed&lt;node[root].l||node[root].r&lt;st) return 0; if(st&lt;=node[root].l&amp;&amp;node[root].r&lt;=ed) return node[root].val; else &#123; pushdown(root); LL a=query(root*2,st,ed); LL b=query(root*2+1,st,ed); pushup(root); return max(a,b); &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;m; memset(a,0,sizeof(a)); int _size=0; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;paint[i].l,&amp;paint[i].r); idx[_size++]=paint[i].l; idx[_size++]=paint[i].l-1; idx[_size++]=paint[i].r; idx[_size++]=paint[i].r+1; &#125; sort(idx,idx+_size); _size=unique(idx,idx+_size)-idx; build(1,1,_size); for(int i=1;i&lt;=m;i++) &#123; int l=lower_bound(idx,idx+_size,paint[i].l)-idx+1; int r=lower_bound(idx,idx+_size,paint[i].r)-idx+1; update(1,l,r,i); &#125; int cnt=0; for(int i=1;i&lt;=_size;i++) &#123; int tmp=query(1,i,i); if(tmp&gt;0) idx[cnt++]=tmp; &#125; sort(idx,idx+cnt); cout&lt;&lt;unique(idx,idx+cnt)-idx&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-3468 A Simple Problem with Integers]]></title>
    <url>%2F2019%2F04%2F13%2FPOJ-3468-A-Simple-Problem-with-Integers%2F</url>
    <content type="text"><![CDATA[You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.Each of the next Q lines represents an operation.“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.“Q a b” means querying the sum of Aa, Aa+1, … , Ab.OutputYou need to answer all Q commands in order. One answer in a line.Sample Input10 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4Sample Output455915HintThe sums may exceed the range of 32-bit integers.这道题是区间修改的板子题了。区间修改和点修改最大的区别就是使用了延迟标记，即子区间不立即更新增加了多少，而是记录下增加了多少值还未更新，在需要用到的时候再进行更新。那么什么时候需要更新呢，就是需要使用未更新的节点的值的时候（更新、查询时）。代码主要参考了https://blog.csdn.net/acceptedxukai/article/details/6933446 ，和之前传五个参不同，把每个点的左右边界都封装进了结构体，这样比较好看懂。AC代码：`cpp#include#includeusing namespace std;const int maxn=1e5+10;#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1long long sum[4maxn],add[4maxn];struct node{int l,r;int mid(){return (l+r)&gt;&gt;1;}}tree[4*maxn];void pushup(int rt){sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];}void pushdown(int rt,int m){if(add[rt]){add[rt&lt;&lt;1]+=add[rt];add[rt&lt;&lt;1|1]+=add[rt];sum[rt&lt;&lt;1]+=add[rt](m-(m&gt;&gt;1));sum[rt&lt;&lt;1|1]+=add[rt](m&gt;&gt;1);add[rt]=0;}}void build(int l,int r,int rt){tree[rt].l=l;tree[rt].r=r;add[rt]=0;if(l==r){scanf(“%lld”,&amp;sum[rt]);return ;}int m=tree[rt].mid();build(lson);build(rson);pushup(rt);}void update(int c,int l,int r,int rt) //表示对区间[l,r]内的每个数均加c，rt是根节点{if(tree[rt].l==l&amp;&amp;tree[rt].r==r){add[rt]+=c;sum[rt]+=(long long )c*(r-l+1);return ;}if(tree[rt].l==tree[rt].r)return ;pushdown(rt,tree[rt].r-tree[rt].l+1);int m=tree[rt].mid();if(r&lt;=m)update(c,l,r,rt&lt;&lt;1);else if(l&gt;m)update(c,l,r,rt&lt;&lt;1|1);else{update(c,l,m,rt&lt;&lt;1);update(c,m+1,r,rt&lt;&lt;1|1);}pushup(rt);}long long query(int l,int r,int rt){if(l==tree[rt].l&amp;&amp;r==tree[rt].r)return sum[rt];pushdown(rt,tree[rt].r-tree[rt].l+1);int m=tree[rt].mid();long long ans=0;if(r&lt;=m)ans+=query(l,r,rt&lt;&lt;1);else if(l&gt;m)ans+=query(l,r,rt&lt;&lt;1|1);else{ans+=query(l,m,rt&lt;&lt;1);ans+=query(m+1,r,rt&lt;&lt;1|1);}return ans;}int main(){int n,m;while(cin&gt;&gt;n&gt;&gt;m){build(1,n,1);while(m–){string s;cin&gt;&gt;s;int a,b,c;if(s[0]==’Q’){scanf(“%d %d”,&amp;a,&amp;b);cout&lt;&lt;query(a,b,1)&lt;&lt;endl;}else{scanf(“%d %d %d”,&amp;a,&amp;b,&amp;c);}return 0;}]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1754 I Hate It]]></title>
    <url>%2F2019%2F04%2F11%2FHDU-1754-I-Hate-It%2F</url>
    <content type="text"><![CDATA[很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。Input本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。Output对于每一次询问操作，在一行里面输出最高成绩。Sample Input5 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5Sample Output5659HintHuge input,the C function scanf() will work better than cin依然是超级板子的线段树，这次是求最大值了。注意点在上一题说的差不多了。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;int a[4*maxn];const int INF=0x3f3f3f3f;void pushup(int i)&#123; a[i]=max(a[i*2],a[i*2+1]);&#125;void build(int i,int l,int r)&#123; if(l==r) &#123; scanf("%d",&amp;a[i]); return; &#125; int m=(l+r)/2; build(i*2,l,m); build(i*2+1,m+1,r); pushup(i);&#125;int query(int ql,int qr,int i,int l,int r)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return a[i]; int m=(l+r)/2; int maxx=-INF; if(ql&lt;=m) maxx=max(maxx,query(ql,qr,i*2,l,m)); if(qr&gt;m) maxx=max(maxx,query(ql,qr,i*2+1,m+1,r)); return maxx;&#125;void update(int id,int val,int i,int l,int r)&#123; if(l==r) &#123; a[i]=val; return; &#125; int m=(l+r)/2; if(id&lt;=m) update(id,val,i*2,l,m); else update(id,val,i*2+1,m+1,r); pushup(i);&#125;int main()&#123; int n,m; string s; int x,y; while(cin&gt;&gt;n&gt;&gt;m) &#123; build(1,1,n); while(m--) &#123; cin&gt;&gt;s; scanf("%d%d",&amp;x,&amp;y); if(s[0]=='Q') cout&lt;&lt;query(x,y,1,1,n)&lt;&lt;endl; else update(x,y,1,1,n); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1166]]></title>
    <url>%2F2019%2F04%2F11%2FHDU-1166%2F</url>
    <content type="text"><![CDATA[C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.Input第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。Sample Input1101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10EndSample OutputCase 1:63359这道题基本就是线段树的板子题了，虽然蓝书讲的是最小值，但是换成和也不难理解。要注意的是和mid判断的时候是大于/小于还是大于等于/小于等于，边界很容易出错。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e4+10;int sum[4*maxn];void pushup(int i)&#123; sum[i]=sum[i*2]+sum[i*2+1];&#125;void build(int i,int l,int r)&#123; if(l==r) &#123; scanf("%d",&amp;sum[i]); return; &#125; int m=(l+r)/2; build(i*2,l,m); build(i*2+1,m+1,r); pushup(i);&#125;int query(int ql,int qr,int i,int l,int r)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return sum[i]; int m=(l+r)/2; int ans=0; if(ql&lt;=m) ans+=query(ql,qr,i*2,l,m); if(qr&gt;m) ans+=query(ql,qr,i*2+1,m+1,r); return ans;&#125;void update(int id,int val,int i,int l,int r)&#123; if(l==r) &#123; sum[i]+=val; return; &#125; int m=(l+r)/2; if(id&lt;=m) update(id,val,i*2,l,m); else update(id,val,i*2+1,m+1,r); pushup(i);&#125;int main()&#123; int T,n,kase=0; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n; build(1,1,n); string s; int x,y; printf("Case %d:\n",++kase); while(cin&gt;&gt;s) &#123; if(s[0]=='E') break; scanf("%d%d",&amp;x,&amp;y); if(s[0]=='A') update(x,y,1,1,n); if(s[0]=='S') update(x,-y,1,1,n); if(s[0]=='Q') printf("%d\n",query(x,y,1,1,n)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first of all]]></title>
    <url>%2F2019%2F04%2F09%2Ffirst-of-all%2F</url>
    <content type="text"><![CDATA[CSDN过于招摇，启动流浪博客计划，，，]]></content>
      <categories>
        <category>水</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
