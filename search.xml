<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU - 1754 I Hate It]]></title>
    <url>%2F2019%2F04%2F11%2FHDU-1754-I-Hate-It%2F</url>
    <content type="text"><![CDATA[很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output对于每一次询问操作，在一行里面输出最高成绩。 Sample Input5 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5 Sample Output5659 HintHuge input,the C function scanf() will work better than cin 依然是超级板子的线段树，这次是求最大值了。注意点在上一题说的差不多了。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;int a[4*maxn];const int INF=0x3f3f3f3f;void pushup(int i)&#123; a[i]=max(a[i*2],a[i*2+1]);&#125;void build(int i,int l,int r)&#123; if(l==r) &#123; scanf("%d",&amp;a[i]); return; &#125; int m=(l+r)/2; build(i*2,l,m); build(i*2+1,m+1,r); pushup(i);&#125;int query(int ql,int qr,int i,int l,int r)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return a[i]; int m=(l+r)/2; int maxx=-INF; if(ql&lt;=m) maxx=max(maxx,query(ql,qr,i*2,l,m)); if(qr&gt;m) maxx=max(maxx,query(ql,qr,i*2+1,m+1,r)); return maxx;&#125;void update(int id,int val,int i,int l,int r)&#123; if(l==r) &#123; a[i]=val; return; &#125; int m=(l+r)/2; if(id&lt;=m) update(id,val,i*2,l,m); else update(id,val,i*2+1,m+1,r); pushup(i);&#125;int main()&#123; int n,m; string s; int x,y; while(cin&gt;&gt;n&gt;&gt;m) &#123; build(1,1,n); while(m--) &#123; cin&gt;&gt;s; scanf("%d%d",&amp;x,&amp;y); if(s[0]=='Q') cout&lt;&lt;query(x,y,1,1,n)&lt;&lt;endl; else update(x,y,1,1,n); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1166]]></title>
    <url>%2F2019%2F04%2F11%2FHDU-1166%2F</url>
    <content type="text"><![CDATA[C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令 Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input1101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample OutputCase 1:63359 这道题基本就是线段树的板子题了，虽然蓝书讲的是最小值，但是换成和也不难理解。要注意的是和mid判断的时候是大于/小于还是大于等于/小于等于，边界很容易出错。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e4+10;int sum[4*maxn];void pushup(int i)&#123; sum[i]=sum[i*2]+sum[i*2+1];&#125;void build(int i,int l,int r)&#123; if(l==r) &#123; scanf("%d",&amp;sum[i]); return; &#125; int m=(l+r)/2; build(i*2,l,m); build(i*2+1,m+1,r); pushup(i);&#125;int query(int ql,int qr,int i,int l,int r)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return sum[i]; int m=(l+r)/2; int ans=0; if(ql&lt;=m) ans+=query(ql,qr,i*2,l,m); if(qr&gt;m) ans+=query(ql,qr,i*2+1,m+1,r); return ans;&#125;void update(int id,int val,int i,int l,int r)&#123; if(l==r) &#123; sum[i]+=val; return; &#125; int m=(l+r)/2; if(id&lt;=m) update(id,val,i*2,l,m); else update(id,val,i*2+1,m+1,r); pushup(i);&#125;int main()&#123; int T,n,kase=0; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n; build(1,1,n); string s; int x,y; printf("Case %d:\n",++kase); while(cin&gt;&gt;s) &#123; if(s[0]=='E') break; scanf("%d%d",&amp;x,&amp;y); if(s[0]=='A') update(x,y,1,1,n); if(s[0]=='S') update(x,-y,1,1,n); if(s[0]=='Q') printf("%d\n",query(x,y,1,1,n)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first of all]]></title>
    <url>%2F2019%2F04%2F09%2Ffirst-of-all%2F</url>
    <content type="text"><![CDATA[CSDN过于招摇，启动流浪博客计划，，，]]></content>
      <categories>
        <category>水</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
