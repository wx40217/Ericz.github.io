<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UVALive - 3026 Period]]></title>
    <url>%2F2019%2F04%2F21%2FUVALive-3026-Period%2F</url>
    <content type="text"><![CDATA[For each prefix of a given string S with N characters (each character has an ASCII code between 97 and126, inclusive), we want to know whether the prefix is a periodic string. That is, for each i (2 ≤ i ≤ N)we want to know the largest K &gt; 1 (if there is one) such that the prefix of S with length i can bewritten as AK, that is A concatenated K times, for some string A. Of course, we also want to knowthe period K.InputThe input file consists of several test cases. Each test case consists of two lines. The first one containsN (2 ≤ N ≤ 1000000) the size of the string S. The second line contains the string S. The input fileends with a line, having the number zero on it.OutputFor each test case, output ‘Test case #’ and the consecutive test case number on a single line; then, foreach prefix with length i that has a period K &gt; 1, output the prefix size i and the period K separatedby a single space; the prefix sizes must be in increasing order. Print a blank line after each test case.Sample Input3aaa12aabaabaabaab0Sample OutputTest case #12 23 3Test case #22 26 29 312 4这题说是kmp，其实是用到了一部分kmp的思想。kmp网上的介绍很多了不做赘述，这里用到的实际是next数组的思想。很容易想到，如果你和一个子串不能匹配，那么和他相同的子串你也不能匹配。next数组的作用就是告诉程序，我这前边有多少个字符是已经出现过了，你看着匹配吧。放到这个程序里，就是你已经知道next数组里重复的个数了，如果k(i-next[i])=i成立，那就是一个循环节uva居然不能用next命名 搞得我ce了一次AC代码：12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+10;int f[maxn];string p;int main()&#123; int n,kase=0; while(cin&gt;&gt;n&amp;&amp;n) &#123; cin&gt;&gt;p; string t; f[0]=0; f[1]=0; for(int i=1;i&lt;n;i++) &#123; int j=f[i]; while(j&amp;&amp;p[i]!=p[j]) j=f[j]; f[i+1]=(p[i]==p[j]?j+1:0); &#125; printf("Test case #%d\n",++kase); for(int i=2;i&lt;=n;i++) if(f[i]&gt;0 &amp;&amp; i%(i-f[i])==0) cout&lt;&lt;i&lt;&lt;' '&lt;&lt;i/(i-f[i])&lt;&lt;endl; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive - 3942 Remember the Word]]></title>
    <url>%2F2019%2F04%2F19%2FUVALive-3942-Remember-the-Word%2F</url>
    <content type="text"><![CDATA[Neal is very curious about combinatorial problems, and now here comes a problem about words. Knowing that Ray has a photographic memory and this may not trouble him, Neal gives it to Jiejie.Since Jiejie can’t remember numbers clearly, he just uses sticks to help himself. Allowing for Jiejie’sonly 20071027 sticks, he can only record the remainders of the numbers divided by total amount ofsticks.The problem is as follows: a word needs to be divided into small pieces in such a way that eachpiece is from some given set of words. Given a word and the set of words, Jiejie should calculate thenumber of ways the given word can be divided, using the words in the set.InputThe input file contains multiple test cases. For each test case: the first line contains the given wordwhose length is no more than 300 000.The second line contains an integer S, 1 ≤ S ≤ 4000.Each of the following S lines contains one word from the set. Each word will be at most 100characters long. There will be no two identical words and all letters in the words will be lowercase.There is a blank line between consecutive test cases.You should proceed to the end of file.OutputFor each test case, output the number, as described above, from the task description modulo 20071027.Sample Inputabcd4abcdabSample OutputCase 1: 2很容易能反应出这是一道DP，设dp(i)表示原字符串的子串[i,len-1]的划分方案数，那么dp(i)=sum{dp(i+len(x)) | x是某个单词，同时x为[i,len-1]的前缀 }，边界是dp(len)=1。但是问题是怎么找出是前缀的x，这时候就要使用前缀树了。说是这么说 我做的还是迷迷糊糊的AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int mod=20071027;const int maxn=4e5+10;string p,s;int trie[maxn][26],tot;int deep[maxn];bool isword[maxn];int dp[maxn];int num,len;void init()&#123; len=p.size(); tot=0; memset(trie,0,sizeof(trie)); memset(isword,0,sizeof(isword)); memset(deep,0,sizeof(deep)); memset(dp,-1,sizeof(dp));&#125;int dfs(int i)&#123; if(i==len) return 1; if(dp[i]!=-1) return dp[i]; int node=0,ans=0; for(int j=i;j&lt;len;++j) &#123; int id=p[j]-'a'; node=trie[node][id]; if(isword[node]) ans=(ans+dfs(i+deep[node]))%mod; if(!node) break; &#125; return dp[i]=ans;&#125;void insert()&#123; int node=0; for(int i=0;s[i];i++) &#123; int id=s[i]-'a'; if(!trie[node][id]) &#123; trie[node][id]=++tot; deep[trie[node][id]]=deep[node]+1; &#125; node=trie[node][id]; &#125; isword[node]=true;&#125;int main()&#123; int kase=0; while(cin&gt;&gt;p) &#123; init(); cin&gt;&gt;num; while(num--) &#123; cin&gt;&gt;s; insert(); &#125; int ans=dfs(0); printf("Case %d: %d\n",++kase,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ - 3264 Balanced Lineup]]></title>
    <url>%2F2019%2F04%2F17%2FPOJ-3264-Balanced-Lineup%2F</url>
    <content type="text"><![CDATA[For the daily milking, Farmer John’s N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height.Farmer John has made a list of Q (1 ≤ Q ≤ 200,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.InputLine 1: Two space-separated integers, N and Q.Lines 2.. N+1: Line i+1 contains a single integer that is the height of cow iLines N+2.. N+ Q+1: Two integers A and B (1 ≤ A ≤ B ≤ N), representing the range of cows from A to B inclusive.OutputLines 1.. Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range.Sample Input6 31734251 54 62 2Sample Output630这道题和前面的题相比反倒难度下降了……就是维护最大值和最小值，没了，甚至没有更新只有查询。。。。。。AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn=7e4+10;struct Node&#123; int l,r; int minn,maxx;&#125;tree;Node node[4*maxn];int num[maxn],minn,maxx;void build(int o,int l,int r)&#123; node[o].l=l;node[o].r=r; if(node[o].l==node[o].r) &#123; node[o].maxx=node[o].minn=num[l]; return; &#125; int mid=(node[o].l+node[o].r)/2; build(o&lt;&lt;1,l,mid); build(o&lt;&lt;1|1,mid+1,r); node[o].maxx=max(node[o&lt;&lt;1].maxx,node[o&lt;&lt;1|1].maxx); node[o].minn=min(node[o&lt;&lt;1].minn,node[o&lt;&lt;1|1].minn);&#125;void query(int o,int l,int r)&#123; if(node[o].l==l&amp;&amp;node[o].r==r) &#123; maxx=max(node[o].maxx,maxx); minn=min(node[o].minn,minn); return; &#125; int mid=(node[o].l+node[o].r)/2; if(l&gt;mid) query(o&lt;&lt;1|1,l,r); else if(r&lt;=mid) query(o&lt;&lt;1,l,r); else &#123; query(o&lt;&lt;1,l,mid); query(o&lt;&lt;1|1,mid+1,r); &#125;&#125;int main()&#123; int n,m,a,b; memset(node,0,sizeof(node)); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;num[i]); build(1,1,n); while(m--) &#123; scanf("%d%d",&amp;a,&amp;b); maxx=0;minn=0x3f3f3f3f; query(1,a,b); cout&lt;&lt;maxx-minn&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ - 1610 Count the Colors]]></title>
    <url>%2F2019%2F04%2F17%2FZOJ-1610-Count-the-Colors%2F</url>
    <content type="text"><![CDATA[Painting some colored segments on a line, some previously painted segments may be covered by some the subsequent ones.Your task is counting the segments of different colors you can see at last.InputThe first line of each data set contains exactly one integer n, 1 &lt;= n &lt;= 8000, equal to the number of colored segments.Each of the following n lines consists of exactly 3 nonnegative integers separated by single spaces:x1 x2 cx1 and x2 indicate the left endpoint and right endpoint of the segment, c indicates the color of the segment.All the numbers are in the range [0, 8000], and they are all integers.Input may contain several data set, process to the end of file.OutputEach line of the output should contain a color index that can be seen from the top, following the count of the segments of this color, they should be printed according to the color index.If some color can’t be seen, you shouldn’t print it.Print a blank line after every dataset.Sample Input50 4 40 3 13 4 20 2 20 2 340 1 13 4 11 3 21 3 160 1 01 2 12 3 11 2 02 3 01 2 1Sample Output1 12 13 11 10 21 1这题本身是一个区间覆盖的题，但是存在边界的问题，所以在数据处理上要注意边界的位置。AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=8e3+10;struct Node&#123; int l,r; int color;&#125;node[4*maxn];int color[maxn];int temp;void build(int i,int l,int r)&#123; node[i].l=l; node[i].r=r; node[i].color=-1; if(l+1==r) return; int mid=(l+r)&gt;&gt;1; build(i&lt;&lt;1,l,mid); build(i&lt;&lt;1|1,mid,r);&#125;void insert(int i,int l,int r,int c)&#123; if(l==r) return; if(node[i].color==c) return; if(l&lt;=node[i].l&amp;&amp;r&gt;=node[i].r) &#123; node[i].color=c; return; &#125; if(node[i].color&gt;=0) &#123; node[i&lt;&lt;1].color=node[i].color; node[i&lt;&lt;1|1].color=node[i].color; node[i].color=-2; &#125; int mid=(node[i].l+node[i].r)&gt;&gt;1; if(r&lt;=mid) insert(i&lt;&lt;1,l,r,c); else if(l&gt;=mid) insert(i&lt;&lt;1|1,l,r,c); else &#123; insert(i&lt;&lt;1,l,mid,c); insert(i&lt;&lt;1|1,mid,r,c); &#125; node[i].color=-2;&#125;void count(int i)&#123; if(node[i].color==-1) &#123; temp=-1; return; &#125; if(node[i].color!=-2) &#123; if(node[i].color!=temp) &#123; color[node[i].color]++; temp=node[i].color; &#125; return; &#125; if(node[i].l+1!=node[i].r) &#123; count(i&lt;&lt;1); count((i&lt;&lt;1)|1); &#125;&#125;int main()&#123; int n,a,b,c; int maxx; while(cin&gt;&gt;n) &#123; build(1,0,8000); maxx=0; while(n--) &#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); insert(1,a,b,c); maxx=max(c,maxx); &#125; temp=-1; memset(color,0,sizeof(color)); count(1); for(int i=0;i&lt;=maxx;i++) if(color[i]) cout&lt;&lt;i&lt;&lt;' '&lt;&lt;color[i]&lt;&lt;endl; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1698 Just a Hook]]></title>
    <url>%2F2019%2F04%2F16%2FHDU-1698-Just-a-Hook%2F</url>
    <content type="text"><![CDATA[In the game of DotA, Pudge’s meat hook is actually the most horrible thing for most of the heroes. The hook is made up of several consecutive metallic sticks which are of the same length.Now Pudge wants to do some operations on the hook.Let us number the consecutive metallic sticks of the hook from 1 to N. For each operation, Pudge can change the consecutive metallic sticks, numbered from X to Y, into cupreous sticks, silver sticks or golden sticks.The total value of the hook is calculated as the sum of values of N metallic sticks. More precisely, the value for each kind of stick is calculated as follows:For each cupreous stick, the value is 1.For each silver stick, the value is 2.For each golden stick, the value is 3.Pudge wants to know the total value of the hook after performing the operations.You may consider the original hook is made up of cupreous sticks.InputThe input consists of several test cases. The first line of the input is the number of the cases. There are no more than 10 cases.For each case, the first line contains an integer N, 1&lt;=N&lt;=100,000, which is the number of the sticks of Pudge’s meat hook and the second line contains an integer Q, 0&lt;=Q&lt;=100,000, which is the number of the operations.Next Q lines, each line contains three integers X, Y, 1&lt;=X&lt;=Y&lt;=N, Z, 1&lt;=Z&lt;=3, which defines an operation: change the sticks numbered from X to Y into the metal kind Z, where Z=1 represents the cupreous kind, Z=2 represents the silver kind and Z=3 represents the golden kind.OutputFor each case, print a number in a line representing the total value of the hook after the operations. Use the format in the example.Sample Input11021 5 25 9 3Sample OutputCase 1: The total value of the hook is 24.这道题是线段树区间覆盖的板子题了（不带查询的板子题），蓝书上说的区间覆盖有点悬，但是实际上，只要有新的覆盖就把旧的延迟标记覆盖了就完事了。不过这也让我想到，如果有覆盖和更新并存的情况，也是直接处理就行吗……顺便吐槽 区间覆盖好像没一个确定的名字，搜半天搜不到，都是区间更新的AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int sum[4*maxn],ans[4*maxn];void pushup(int o)&#123; sum[o]=sum[o&lt;&lt;1]+sum[o&lt;&lt;1|1];&#125;void pushdown(int o,int l,int r)&#123; if(ans[o]) &#123; int m=l+(r-l)/2; ans[o&lt;&lt;1]=ans[o&lt;&lt;1|1]=ans[o]; sum[o&lt;&lt;1]=(m-l+1)*ans[o]; sum[o&lt;&lt;1|1]=(r-m)*ans[o]; ans[o]=0; &#125;&#125;void build(int l,int r,int o)&#123; int m=l+(r-l)/2; ans[o]=0; if(l==r) &#123; sum[o]=1; return; &#125; build(l,m,o&lt;&lt;1); build(m+1,r,o&lt;&lt;1|1); pushup(o);&#125;void update(int L,int R,int c,int l,int r,int o)&#123; int m=l+(r-l)/2; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; ans[o]=c; sum[o]=(r-l+1)*c; return; &#125; pushdown(o,l,r); if(L&lt;=m) update(L,R,c,l,m,o&lt;&lt;1); if(m&lt;R) update(L,R,c,m+1,r,o&lt;&lt;1|1); pushup(o);&#125;int main()&#123; int t; cin&gt;&gt;t; int kase=0; while(t--) &#123; int n,q; cin&gt;&gt;n&gt;&gt;q; build(1,n,1); while(q--) &#123; int l,r,c; scanf("%d%d%d",&amp;l,&amp;r,&amp;c); update(l,r,c,1,n,1); &#125; printf("Case %d: The total value of the hook is %d.\n",++kase,sum[1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ - 2528 Mayor's posters]]></title>
    <url>%2F2019%2F04%2F16%2FPOJ-2528-Mayor-s-posters%2F</url>
    <content type="text"><![CDATA[The citizens of Bytetown, AB, could not stand that the candidates in the mayoral election campaign have been placing their electoral posters at all places at their whim. The city council has finally decided to build an electoral wall for placing the posters and introduce the following rules:Every candidate can place exactly one poster on the wall.All posters are of the same height equal to the height of the wall; the width of a poster can be any integer number of bytes (byte is the unit of length in Bytetown).The wall is divided into segments and the width of each segment is one byte.Each poster must completely cover a contiguous number of wall segments.They have built a wall 10000000 bytes long (such that there is enough place for all candidates). When the electoral campaign was restarted, the candidates were placing their posters on the wall and their posters differed widely in width. Moreover, the candidates started placing their posters on wall segments already occupied by other posters. Everyone in Bytetown was curious whose posters will be visible (entirely or in part) on the last day before elections.Your task is to find the number of visible posters when all the posters are placed given the information about posters’ size, their place and order of placement on the electoral wall.InputThe first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 &lt;= n &lt;= 10000. The subsequent n lines describe the posters in the order in which they were placed. The i-th line among the n lines contains two integer numbers l i and ri which are the number of the wall segment occupied by the left end and the right end of the i-th poster, respectively. We know that for each 1 &lt;= i &lt;= n, 1 &lt;= l i &lt;= ri &lt;= 10000000. After the i-th poster is placed, it entirely covers all wall segments numbered l i, l i+1 ,… , ri.OutputFor each input data set print the number of visible posters after all the posters are placed.The picture below illustrates the case of the sample input.Sample Input151 42 68 103 47 10Sample Output4这道题……emmmmmm中间隔了个数学建模，实际我完全不知道自己做的是啥了，只知道这是线段树加数据离散化，然而数据离散化我也不会，问题很大。AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=4e4+5;int m,a[maxn];int idx[maxn];struct Paint&#123; int l,r;&#125;paint[maxn];struct Node&#123; int l,r; int val,lazy; void update(LL x) &#123; val=(r-l+1)*x; lazy=x; &#125;&#125;node[4*maxn];void pushdown(int root)&#123; if(node[root].lazy) &#123; node[root*2].update(node[root].lazy); node[root*2+1].update(node[root].lazy); node[root].lazy=0; &#125;&#125;void pushup(int root)&#123; node[root].val=max(node[root*2].val,node[root*2+1].val);&#125;void build(int root,int l,int r)&#123; node[root].l=l; node[root].r=r; node[root].val=0; node[root].lazy=0; if(l==r) node[root].val=a[l]; else &#123; int mid=l+(r-l)/2; build(root*2,l,mid); build(root*2+1,mid+1,r); pushup(root); &#125;&#125;void update(int root,int st,int ed,int val)&#123; if(st&gt;node[root].r||ed&lt;node[root].l) return ; if(st&lt;=node[root].l&amp;&amp;node[root].r&lt;=ed) node[root].update(val); else &#123; pushdown(root); update(root*2,st,ed,val); update(root*2+1,st,ed,val); pushup(root); &#125;&#125;int query(int root,int st,int ed)&#123; if(ed&lt;node[root].l||node[root].r&lt;st) return 0; if(st&lt;=node[root].l&amp;&amp;node[root].r&lt;=ed) return node[root].val; else &#123; pushdown(root); LL a=query(root*2,st,ed); LL b=query(root*2+1,st,ed); pushup(root); return max(a,b); &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;m; memset(a,0,sizeof(a)); int _size=0; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;paint[i].l,&amp;paint[i].r); idx[_size++]=paint[i].l; idx[_size++]=paint[i].l-1; idx[_size++]=paint[i].r; idx[_size++]=paint[i].r+1; &#125; sort(idx,idx+_size); _size=unique(idx,idx+_size)-idx; build(1,1,_size); for(int i=1;i&lt;=m;i++) &#123; int l=lower_bound(idx,idx+_size,paint[i].l)-idx+1; int r=lower_bound(idx,idx+_size,paint[i].r)-idx+1; update(1,l,r,i); &#125; int cnt=0; for(int i=1;i&lt;=_size;i++) &#123; int tmp=query(1,i,i); if(tmp&gt;0) idx[cnt++]=tmp; &#125; sort(idx,idx+cnt); cout&lt;&lt;unique(idx,idx+cnt)-idx&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-3468 A Simple Problem with Integers]]></title>
    <url>%2F2019%2F04%2F13%2FPOJ-3468-A-Simple-Problem-with-Integers%2F</url>
    <content type="text"><![CDATA[You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.Each of the next Q lines represents an operation.“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.“Q a b” means querying the sum of Aa, Aa+1, … , Ab.OutputYou need to answer all Q commands in order. One answer in a line.Sample Input10 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4Sample Output455915HintThe sums may exceed the range of 32-bit integers.这道题是区间修改的板子题了。区间修改和点修改最大的区别就是使用了延迟标记，即子区间不立即更新增加了多少，而是记录下增加了多少值还未更新，在需要用到的时候再进行更新。那么什么时候需要更新呢，就是需要使用未更新的节点的值的时候（更新、查询时）。代码主要参考了https://blog.csdn.net/acceptedxukai/article/details/6933446 ，和之前传五个参不同，把每个点的左右边界都封装进了结构体，这样比较好看懂。AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn=1e5+10;#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1long long sum[4*maxn],add[4*maxn];struct node&#123; int l,r; int mid() &#123; return (l+r)&gt;&gt;1; &#125;&#125;tree[4*maxn];void pushup(int rt)&#123; sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];&#125;void pushdown(int rt,int m)&#123; if(add[rt]) &#123; add[rt&lt;&lt;1]+=add[rt]; add[rt&lt;&lt;1|1]+=add[rt]; sum[rt&lt;&lt;1]+=add[rt]*(m-(m&gt;&gt;1)); sum[rt&lt;&lt;1|1]+=add[rt]*(m&gt;&gt;1); add[rt]=0; &#125;&#125;void build(int l,int r,int rt)&#123; tree[rt].l=l; tree[rt].r=r; add[rt]=0; if(l==r) &#123; scanf("%lld",&amp;sum[rt]); return ; &#125; int m=tree[rt].mid(); build(lson); build(rson); pushup(rt);&#125;void update(int c,int l,int r,int rt) //表示对区间[l,r]内的每个数均加c，rt是根节点&#123; if(tree[rt].l==l&amp;&amp;tree[rt].r==r) &#123; add[rt]+=c; sum[rt]+=(long long )c*(r-l+1); return ; &#125; if(tree[rt].l==tree[rt].r) return ; pushdown(rt,tree[rt].r-tree[rt].l+1); int m=tree[rt].mid(); if(r&lt;=m) update(c,l,r,rt&lt;&lt;1); else if(l&gt;m) update(c,l,r,rt&lt;&lt;1|1); else &#123; update(c,l,m,rt&lt;&lt;1); update(c,m+1,r,rt&lt;&lt;1|1); &#125; pushup(rt);&#125;long long query(int l,int r,int rt)&#123; if(l==tree[rt].l&amp;&amp;r==tree[rt].r) return sum[rt]; pushdown(rt,tree[rt].r-tree[rt].l+1); int m=tree[rt].mid(); long long ans=0; if(r&lt;=m) ans+=query(l,r,rt&lt;&lt;1); else if(l&gt;m) ans+=query(l,r,rt&lt;&lt;1|1); else &#123; ans+=query(l,m,rt&lt;&lt;1); ans+=query(m+1,r,rt&lt;&lt;1|1); &#125; return ans;&#125;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; build(1,n,1); while(m--) &#123; string s; cin&gt;&gt;s; int a,b,c; if(s[0]=='Q') &#123; scanf("%d %d",&amp;a,&amp;b); cout&lt;&lt;query(a,b,1)&lt;&lt;endl; &#125; else &#123; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); update(c,a,b,1); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1754 I Hate It]]></title>
    <url>%2F2019%2F04%2F11%2FHDU-1754-I-Hate-It%2F</url>
    <content type="text"><![CDATA[很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。Input本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。Output对于每一次询问操作，在一行里面输出最高成绩。Sample Input5 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5Sample Output5659HintHuge input,the C function scanf() will work better than cin依然是超级板子的线段树，这次是求最大值了。注意点在上一题说的差不多了。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;int a[4*maxn];const int INF=0x3f3f3f3f;void pushup(int i)&#123; a[i]=max(a[i*2],a[i*2+1]);&#125;void build(int i,int l,int r)&#123; if(l==r) &#123; scanf("%d",&amp;a[i]); return; &#125; int m=(l+r)/2; build(i*2,l,m); build(i*2+1,m+1,r); pushup(i);&#125;int query(int ql,int qr,int i,int l,int r)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return a[i]; int m=(l+r)/2; int maxx=-INF; if(ql&lt;=m) maxx=max(maxx,query(ql,qr,i*2,l,m)); if(qr&gt;m) maxx=max(maxx,query(ql,qr,i*2+1,m+1,r)); return maxx;&#125;void update(int id,int val,int i,int l,int r)&#123; if(l==r) &#123; a[i]=val; return; &#125; int m=(l+r)/2; if(id&lt;=m) update(id,val,i*2,l,m); else update(id,val,i*2+1,m+1,r); pushup(i);&#125;int main()&#123; int n,m; string s; int x,y; while(cin&gt;&gt;n&gt;&gt;m) &#123; build(1,1,n); while(m--) &#123; cin&gt;&gt;s; scanf("%d%d",&amp;x,&amp;y); if(s[0]=='Q') cout&lt;&lt;query(x,y,1,1,n)&lt;&lt;endl; else update(x,y,1,1,n); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1166]]></title>
    <url>%2F2019%2F04%2F11%2FHDU-1166%2F</url>
    <content type="text"><![CDATA[C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.Input第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。Sample Input1101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10EndSample OutputCase 1:63359这道题基本就是线段树的板子题了，虽然蓝书讲的是最小值，但是换成和也不难理解。要注意的是和mid判断的时候是大于/小于还是大于等于/小于等于，边界很容易出错。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e4+10;int sum[4*maxn];void pushup(int i)&#123; sum[i]=sum[i*2]+sum[i*2+1];&#125;void build(int i,int l,int r)&#123; if(l==r) &#123; scanf("%d",&amp;sum[i]); return; &#125; int m=(l+r)/2; build(i*2,l,m); build(i*2+1,m+1,r); pushup(i);&#125;int query(int ql,int qr,int i,int l,int r)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return sum[i]; int m=(l+r)/2; int ans=0; if(ql&lt;=m) ans+=query(ql,qr,i*2,l,m); if(qr&gt;m) ans+=query(ql,qr,i*2+1,m+1,r); return ans;&#125;void update(int id,int val,int i,int l,int r)&#123; if(l==r) &#123; sum[i]+=val; return; &#125; int m=(l+r)/2; if(id&lt;=m) update(id,val,i*2,l,m); else update(id,val,i*2+1,m+1,r); pushup(i);&#125;int main()&#123; int T,n,kase=0; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n; build(1,1,n); string s; int x,y; printf("Case %d:\n",++kase); while(cin&gt;&gt;s) &#123; if(s[0]=='E') break; scanf("%d%d",&amp;x,&amp;y); if(s[0]=='A') update(x,y,1,1,n); if(s[0]=='S') update(x,-y,1,1,n); if(s[0]=='Q') printf("%d\n",query(x,y,1,1,n)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first of all]]></title>
    <url>%2F2019%2F04%2F09%2Ffirst-of-all%2F</url>
    <content type="text"><![CDATA[CSDN过于招摇，启动流浪博客计划，，，]]></content>
      <categories>
        <category>水</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
