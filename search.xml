<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU 1698 Just a Hook]]></title>
    <url>%2F2019%2F04%2F16%2FHDU-1698-Just-a-Hook%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[POJ - 2528 Mayor's posters]]></title>
    <url>%2F2019%2F04%2F16%2FPOJ-2528-Mayor-s-posters%2F</url>
    <content type="text"><![CDATA[The citizens of Bytetown, AB, could not stand that the candidates in the mayoral election campaign have been placing their electoral posters at all places at their whim. The city council has finally decided to build an electoral wall for placing the posters and introduce the following rules:Every candidate can place exactly one poster on the wall.All posters are of the same height equal to the height of the wall; the width of a poster can be any integer number of bytes (byte is the unit of length in Bytetown).The wall is divided into segments and the width of each segment is one byte.Each poster must completely cover a contiguous number of wall segments.They have built a wall 10000000 bytes long (such that there is enough place for all candidates). When the electoral campaign was restarted, the candidates were placing their posters on the wall and their posters differed widely in width. Moreover, the candidates started placing their posters on wall segments already occupied by other posters. Everyone in Bytetown was curious whose posters will be visible (entirely or in part) on the last day before elections.Your task is to find the number of visible posters when all the posters are placed given the information about posters’ size, their place and order of placement on the electoral wall.InputThe first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 &lt;= n &lt;= 10000. The subsequent n lines describe the posters in the order in which they were placed. The i-th line among the n lines contains two integer numbers l i and ri which are the number of the wall segment occupied by the left end and the right end of the i-th poster, respectively. We know that for each 1 &lt;= i &lt;= n, 1 &lt;= l i &lt;= ri &lt;= 10000000. After the i-th poster is placed, it entirely covers all wall segments numbered l i, l i+1 ,… , ri.OutputFor each input data set print the number of visible posters after all the posters are placed.The picture below illustrates the case of the sample input.Sample Input151 42 68 103 47 10Sample Output4这道题……emmmmmm中间隔了个数学建模，实际我完全不知道自己做的是啥了，只知道这是线段树加数据离散化，然而数据离散化我也不会，问题很大。AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=4e4+5;int m,a[maxn];int idx[maxn];struct Paint&#123; int l,r;&#125;paint[maxn];struct Node&#123; int l,r; int val,lazy; void update(LL x) &#123; val=(r-l+1)*x; lazy=x; &#125;&#125;node[4*maxn];void pushdown(int root)&#123; if(node[root].lazy) &#123; node[root*2].update(node[root].lazy); node[root*2+1].update(node[root].lazy); node[root].lazy=0; &#125;&#125;void pushup(int root)&#123; node[root].val=max(node[root*2].val,node[root*2+1].val);&#125;void build(int root,int l,int r)&#123; node[root].l=l; node[root].r=r; node[root].val=0; node[root].lazy=0; if(l==r) node[root].val=a[l]; else &#123; int mid=l+(r-l)/2; build(root*2,l,mid); build(root*2+1,mid+1,r); pushup(root); &#125;&#125;void update(int root,int st,int ed,int val)&#123; if(st&gt;node[root].r||ed&lt;node[root].l) return ; if(st&lt;=node[root].l&amp;&amp;node[root].r&lt;=ed) node[root].update(val); else &#123; pushdown(root); update(root*2,st,ed,val); update(root*2+1,st,ed,val); pushup(root); &#125;&#125;int query(int root,int st,int ed)&#123; if(ed&lt;node[root].l||node[root].r&lt;st) return 0; if(st&lt;=node[root].l&amp;&amp;node[root].r&lt;=ed) return node[root].val; else &#123; pushdown(root); LL a=query(root*2,st,ed); LL b=query(root*2+1,st,ed); pushup(root); return max(a,b); &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;m; memset(a,0,sizeof(a)); int _size=0; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;paint[i].l,&amp;paint[i].r); idx[_size++]=paint[i].l; idx[_size++]=paint[i].l-1; idx[_size++]=paint[i].r; idx[_size++]=paint[i].r+1; &#125; sort(idx,idx+_size); _size=unique(idx,idx+_size)-idx; build(1,1,_size); for(int i=1;i&lt;=m;i++) &#123; int l=lower_bound(idx,idx+_size,paint[i].l)-idx+1; int r=lower_bound(idx,idx+_size,paint[i].r)-idx+1; update(1,l,r,i); &#125; int cnt=0; for(int i=1;i&lt;=_size;i++) &#123; int tmp=query(1,i,i); if(tmp&gt;0) idx[cnt++]=tmp; &#125; sort(idx,idx+cnt); cout&lt;&lt;unique(idx,idx+cnt)-idx&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树, 离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-3468 A Simple Problem with Integers]]></title>
    <url>%2F2019%2F04%2F13%2FPOJ-3468-A-Simple-Problem-with-Integers%2F</url>
    <content type="text"><![CDATA[You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.Each of the next Q lines represents an operation.“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.“Q a b” means querying the sum of Aa, Aa+1, … , Ab.OutputYou need to answer all Q commands in order. One answer in a line.Sample Input10 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4Sample Output455915HintThe sums may exceed the range of 32-bit integers.这道题是区间修改的板子题了。区间修改和点修改最大的区别就是使用了延迟标记，即子区间不立即更新增加了多少，而是记录下增加了多少值还未更新，在需要用到的时候再进行更新。那么什么时候需要更新呢，就是需要使用未更新的节点的值的时候（更新、查询时）。代码主要参考了https://blog.csdn.net/acceptedxukai/article/details/6933446 ，和之前传五个参不同，把每个点的左右边界都封装进了结构体，这样比较好看懂。AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn=1e5+10;#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1long long sum[4*maxn],add[4*maxn];struct node&#123; int l,r; int mid() &#123; return (l+r)&gt;&gt;1; &#125;&#125;tree[4*maxn];void pushup(int rt)&#123; sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];&#125;void pushdown(int rt,int m)&#123; if(add[rt]) &#123; add[rt&lt;&lt;1]+=add[rt]; add[rt&lt;&lt;1|1]+=add[rt]; sum[rt&lt;&lt;1]+=add[rt]*(m-(m&gt;&gt;1)); sum[rt&lt;&lt;1|1]+=add[rt]*(m&gt;&gt;1); add[rt]=0; &#125;&#125;void build(int l,int r,int rt)&#123; tree[rt].l=l; tree[rt].r=r; add[rt]=0; if(l==r) &#123; scanf("%lld",&amp;sum[rt]); return ; &#125; int m=tree[rt].mid(); build(lson); build(rson); pushup(rt);&#125;void update(int c,int l,int r,int rt) //表示对区间[l,r]内的每个数均加c，rt是根节点&#123; if(tree[rt].l==l&amp;&amp;tree[rt].r==r) &#123; add[rt]+=c; sum[rt]+=(long long )c*(r-l+1); return ; &#125; if(tree[rt].l==tree[rt].r) return ; pushdown(rt,tree[rt].r-tree[rt].l+1); int m=tree[rt].mid(); if(r&lt;=m) update(c,l,r,rt&lt;&lt;1); else if(l&gt;m) update(c,l,r,rt&lt;&lt;1|1); else &#123; update(c,l,m,rt&lt;&lt;1); update(c,m+1,r,rt&lt;&lt;1|1); &#125; pushup(rt);&#125;long long query(int l,int r,int rt)&#123; if(l==tree[rt].l&amp;&amp;r==tree[rt].r) return sum[rt]; pushdown(rt,tree[rt].r-tree[rt].l+1); int m=tree[rt].mid(); long long ans=0; if(r&lt;=m) ans+=query(l,r,rt&lt;&lt;1); else if(l&gt;m) ans+=query(l,r,rt&lt;&lt;1|1); else &#123; ans+=query(l,m,rt&lt;&lt;1); ans+=query(m+1,r,rt&lt;&lt;1|1); &#125; return ans;&#125;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; build(1,n,1); while(m--) &#123; string s; cin&gt;&gt;s; int a,b,c; if(s[0]=='Q') &#123; scanf("%d %d",&amp;a,&amp;b); cout&lt;&lt;query(a,b,1)&lt;&lt;endl; &#125; else &#123; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); update(c,a,b,1); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1754 I Hate It]]></title>
    <url>%2F2019%2F04%2F11%2FHDU-1754-I-Hate-It%2F</url>
    <content type="text"><![CDATA[很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。Input本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。Output对于每一次询问操作，在一行里面输出最高成绩。Sample Input5 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5Sample Output5659HintHuge input,the C function scanf() will work better than cin依然是超级板子的线段树，这次是求最大值了。注意点在上一题说的差不多了。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+10;int a[4*maxn];const int INF=0x3f3f3f3f;void pushup(int i)&#123; a[i]=max(a[i*2],a[i*2+1]);&#125;void build(int i,int l,int r)&#123; if(l==r) &#123; scanf("%d",&amp;a[i]); return; &#125; int m=(l+r)/2; build(i*2,l,m); build(i*2+1,m+1,r); pushup(i);&#125;int query(int ql,int qr,int i,int l,int r)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return a[i]; int m=(l+r)/2; int maxx=-INF; if(ql&lt;=m) maxx=max(maxx,query(ql,qr,i*2,l,m)); if(qr&gt;m) maxx=max(maxx,query(ql,qr,i*2+1,m+1,r)); return maxx;&#125;void update(int id,int val,int i,int l,int r)&#123; if(l==r) &#123; a[i]=val; return; &#125; int m=(l+r)/2; if(id&lt;=m) update(id,val,i*2,l,m); else update(id,val,i*2+1,m+1,r); pushup(i);&#125;int main()&#123; int n,m; string s; int x,y; while(cin&gt;&gt;n&gt;&gt;m) &#123; build(1,1,n); while(m--) &#123; cin&gt;&gt;s; scanf("%d%d",&amp;x,&amp;y); if(s[0]=='Q') cout&lt;&lt;query(x,y,1,1,n)&lt;&lt;endl; else update(x,y,1,1,n); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1166]]></title>
    <url>%2F2019%2F04%2F11%2FHDU-1166%2F</url>
    <content type="text"><![CDATA[C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.Input第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。Sample Input1101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10EndSample OutputCase 1:63359这道题基本就是线段树的板子题了，虽然蓝书讲的是最小值，但是换成和也不难理解。要注意的是和mid判断的时候是大于/小于还是大于等于/小于等于，边界很容易出错。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e4+10;int sum[4*maxn];void pushup(int i)&#123; sum[i]=sum[i*2]+sum[i*2+1];&#125;void build(int i,int l,int r)&#123; if(l==r) &#123; scanf("%d",&amp;sum[i]); return; &#125; int m=(l+r)/2; build(i*2,l,m); build(i*2+1,m+1,r); pushup(i);&#125;int query(int ql,int qr,int i,int l,int r)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return sum[i]; int m=(l+r)/2; int ans=0; if(ql&lt;=m) ans+=query(ql,qr,i*2,l,m); if(qr&gt;m) ans+=query(ql,qr,i*2+1,m+1,r); return ans;&#125;void update(int id,int val,int i,int l,int r)&#123; if(l==r) &#123; sum[i]+=val; return; &#125; int m=(l+r)/2; if(id&lt;=m) update(id,val,i*2,l,m); else update(id,val,i*2+1,m+1,r); pushup(i);&#125;int main()&#123; int T,n,kase=0; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n; build(1,1,n); string s; int x,y; printf("Case %d:\n",++kase); while(cin&gt;&gt;s) &#123; if(s[0]=='E') break; scanf("%d%d",&amp;x,&amp;y); if(s[0]=='A') update(x,y,1,1,n); if(s[0]=='S') update(x,-y,1,1,n); if(s[0]=='Q') printf("%d\n",query(x,y,1,1,n)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first of all]]></title>
    <url>%2F2019%2F04%2F09%2Ffirst-of-all%2F</url>
    <content type="text"><![CDATA[CSDN过于招摇，启动流浪博客计划，，，]]></content>
      <categories>
        <category>水</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
